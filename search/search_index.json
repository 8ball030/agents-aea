{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Software to work for you Do you want to create software to work for you and enrich your life? Autonomous Economic Agents - or AEAs - work continously for your benefit without you having to do anything more than write them and start them up. AEAs are able to act independent of your constant input and to autonomously develop new capabilities. Their goal is to create economic gain for you, their owner. AEAs have a wide range of application areas. Check out the demo section for examples. Bridging Web 2.0 to Web 3.0, AEAs are the future, now. More specifically The AEA framework provides the tools for creating autonomous economic agents. It is a Python-based development suite which equips you with an efficient and easy to understand set of tools for building autonomous economic agents. The framework is super modular, easily extensible, and highly composable. The AEA framework attempts to make agent development as straightforward as web development using popular web frameworks. AEAs achieve their goals with the help of the Fetch.ai OEF - a search and discovery platform for agents - and the Fetch.ai blockchain. Third party systems, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"Welcome"},{"location":"#software-to-work-for-you","text":"Do you want to create software to work for you and enrich your life? Autonomous Economic Agents - or AEAs - work continously for your benefit without you having to do anything more than write them and start them up. AEAs are able to act independent of your constant input and to autonomously develop new capabilities. Their goal is to create economic gain for you, their owner. AEAs have a wide range of application areas. Check out the demo section for examples. Bridging Web 2.0 to Web 3.0, AEAs are the future, now.","title":"Software to work for you"},{"location":"#more-specifically","text":"The AEA framework provides the tools for creating autonomous economic agents. It is a Python-based development suite which equips you with an efficient and easy to understand set of tools for building autonomous economic agents. The framework is super modular, easily extensible, and highly composable. The AEA framework attempts to make agent development as straightforward as web development using popular web frameworks. AEAs achieve their goals with the help of the Fetch.ai OEF - a search and discovery platform for agents - and the Fetch.ai blockchain. Third party systems, such as Ethereum, may also allow AEA integration. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"More specifically"},{"location":"app-areas/","text":"An autonomous economic agent (AEA) is an intelligent agent whose goal is generating economic value for its owner. It can represent machines, humans, or data. There are five general application areas for Fetch.ai AEAs. Inhabitants : agents paired with real world hardware devices such as drones, laptops, heat sensors, etc. Interfaces : facilitation agents which provide the necessary API interfaces for interaction between old (Web 2.0) and new (Web 3.0) economic models. Pure software : software agents living in the digital space that interact with inhabitant and interface agents and others. Digital data sales agents : pure software agents that attach to data sources and sell it via the open economic framework. Representative : an agent which represents an individual's activities on the Fetch.ai network. Multi-agent system vs agent-based modelling The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behaviourial observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Application areas"},{"location":"app-areas/#multi-agent-system-vs-agent-based-modelling","text":"The Fetch.ai multi agent system is a real world multi-agent technological system and, although there is some overlap, it is not the same as agent based modelling where the goal is scientific behaviourial observation rather than practical economic gain. Moreover, there is no restriction to multi . Single-agent applications are also possible.","title":"Multi-agent system vs agent-based modelling"},{"location":"buy-sell/","text":"Todo","title":"Buy sell"},{"location":"car-park/","text":"Warning Work in progress. Car Park Agent Application The Fetch.ai car park agent application is made up of three components: A Raspberry Pi hardware device with camera module viewing a car park. A car park agent GUI running on the Raspberry Pi that collects data on free spaces and serves it up for purchase on the Fetch.ai network. A remote client agent GUI that connects to the Raspberry Pi and buys data. Hardware Car Park Agent GUI Client Agent GUI Raspberry Pi hardware set up The hardware set up is the most time consuming part of these instructions. We assume the developer has some familiarity with Raspberry Pi and refer them to the manufacturer's instructions. However, we do list any problems we encountered and their solutions below. Note We have used the Raspberry Pi 4. You are welcome to use earlier versions but the set up may change slightly. Follow the manufacturer's instructions to set up the Raspberry Pi 4 hardware device: https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/2 . Install and update the OS Install the Raspbian OS and update it. sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade sudo reboot Enable camera, ssh, and VNC Click on the Raspberry symbol in the top left of the screen. Select Preferences then Raspberry Pi Configuration. Enable the Camera, SSH, and VNC options. Set up camera module Follow the manufacturer's instructions to set up the Raspberry Pi Camera module: https://projects.raspberrypi.org/en/projects/getting-started-with-picamera . Configure and test the camera software: https://www.raspberrypi.org/documentation/configuration/camera.md . Set up your Pi to physically view the car park. We'll leave that to you. Potential issues Make sure you use the first port, HDMI 0 on the Pi for the initial setup monitor. If you install the Pi with a used SD card, you will need to reformat the card with NOOBS: https://www.raspberrypi.org/downloads/noobs/ . Fix the screen resolution issues by editing the configuration. sudo raspi-config Select the 1920X1080 resolution option - number 31. Then update the configuration file as follows. Open it. sudo nano /boot/config.txt And make sure the following three lines are commented out. # Enable DRM VC4 V3D driver on top of the dispmanx display stack # dtoverlay=vc4-fkms-v3d # max_framebuffers=2 Agent server application installation Now we are ready to install the car park agent GUI server application on the Raspberry Pi. Get the code cd ~/Desktop git clone https://github.com/fetchai/carpark_agent.git cd carpark_agent Download datafile This is required for the machine learning algorithms. ./car_detection/weights/download_weights.sh Install the required libraries. sudo apt-get install gcc htop vim mc python3-dev ffmpeg virtualenv libatlas-base-dev libsm6 libxext6 clang libblas3 liblapack3 liblapack-dev libblas-dev cython gfortran build-essential libgdal-dev libopenblas-dev liblapack3 liblapacke liblapacke-dev liblcms2-utils liblcms2-2 libwebpdemux2 python3-scipy python3-numpy python3-matplotlib libjasper-dev libqtgui4 libqt4-test protobuf-compiler python3-opencv gpsd gpsd-clients Activate a virtual environment. pip3 install virtualenv ./run_scripts/create_venv.sh source venv/bin/activate Install the software python setup.py develop Note We recommend that using develop as this creates a link to the code and so any changes you make will take immediate effect when you run the code. Run it ./run_scripts/run_carpark_agent.sh You should now see the agent running. Ensure agent start on boot (RPi4 only) Ensure the startup script runs whenever we the Raspberry Pi turns on. crontab -e Pick an editor which will open a text file. Scroll to the bottom and add the following line. @reboot /home/pi/Desktop/carpark_agent/run_scripts/run_carpark_agent.sh Save and reboot. The agent should now start automatically on reboot. Get the Pi's ip address We will need the ip address of the Raspberry Pi to connect remotely. ifconfig Returns something like: ... wlan0: flags = 4163 <UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192 .168.11.9 netmask 255 .255.255.0 broadcast 192 .168.11.255 ... The inet value is the Raspberry Pi's ip address. Connect to the app remotely Download and install the VNC viewer onto your remote laptop: https://www.realvnc.com/en/connect/download/viewer/ . Add the Pi's ip address. You will be prompted for the Raspberry Pi password. The Raspberry Pi's desktop should appear. Get your remote desktop ip Follow the instructiona to get your remote ip address. Connect to the Raspberry Pi Start up the agent, if it is not running - but it should be. cd Desktop/carpark_agent ./run_scripts/run_carpark_agent.sh STOPPED HERE - Monday 28th October The Pi server app instructions come next From \"When it starts up and you see the output from the camera, you can move your camera around so it is looking at the area...","title":"Car park"},{"location":"car-park/#car-park-agent-application","text":"The Fetch.ai car park agent application is made up of three components: A Raspberry Pi hardware device with camera module viewing a car park. A car park agent GUI running on the Raspberry Pi that collects data on free spaces and serves it up for purchase on the Fetch.ai network. A remote client agent GUI that connects to the Raspberry Pi and buys data. Hardware Car Park Agent GUI Client Agent GUI","title":"Car Park Agent Application"},{"location":"car-park/#raspberry-pi-hardware-set-up","text":"The hardware set up is the most time consuming part of these instructions. We assume the developer has some familiarity with Raspberry Pi and refer them to the manufacturer's instructions. However, we do list any problems we encountered and their solutions below. Note We have used the Raspberry Pi 4. You are welcome to use earlier versions but the set up may change slightly. Follow the manufacturer's instructions to set up the Raspberry Pi 4 hardware device: https://projects.raspberrypi.org/en/projects/raspberry-pi-setting-up/2 .","title":"Raspberry Pi hardware set up"},{"location":"car-park/#install-and-update-the-os","text":"Install the Raspbian OS and update it. sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade sudo reboot","title":"Install and update the OS"},{"location":"car-park/#enable-camera-ssh-and-vnc","text":"Click on the Raspberry symbol in the top left of the screen. Select Preferences then Raspberry Pi Configuration. Enable the Camera, SSH, and VNC options.","title":"Enable camera, ssh, and VNC"},{"location":"car-park/#set-up-camera-module","text":"Follow the manufacturer's instructions to set up the Raspberry Pi Camera module: https://projects.raspberrypi.org/en/projects/getting-started-with-picamera . Configure and test the camera software: https://www.raspberrypi.org/documentation/configuration/camera.md . Set up your Pi to physically view the car park. We'll leave that to you.","title":"Set up camera module"},{"location":"car-park/#potential-issues","text":"Make sure you use the first port, HDMI 0 on the Pi for the initial setup monitor. If you install the Pi with a used SD card, you will need to reformat the card with NOOBS: https://www.raspberrypi.org/downloads/noobs/ . Fix the screen resolution issues by editing the configuration. sudo raspi-config Select the 1920X1080 resolution option - number 31. Then update the configuration file as follows. Open it. sudo nano /boot/config.txt And make sure the following three lines are commented out. # Enable DRM VC4 V3D driver on top of the dispmanx display stack # dtoverlay=vc4-fkms-v3d # max_framebuffers=2","title":"Potential issues"},{"location":"car-park/#agent-server-application-installation","text":"Now we are ready to install the car park agent GUI server application on the Raspberry Pi.","title":"Agent server application installation"},{"location":"car-park/#get-the-code","text":"cd ~/Desktop git clone https://github.com/fetchai/carpark_agent.git cd carpark_agent","title":"Get the code"},{"location":"car-park/#download-datafile","text":"This is required for the machine learning algorithms. ./car_detection/weights/download_weights.sh Install the required libraries. sudo apt-get install gcc htop vim mc python3-dev ffmpeg virtualenv libatlas-base-dev libsm6 libxext6 clang libblas3 liblapack3 liblapack-dev libblas-dev cython gfortran build-essential libgdal-dev libopenblas-dev liblapack3 liblapacke liblapacke-dev liblcms2-utils liblcms2-2 libwebpdemux2 python3-scipy python3-numpy python3-matplotlib libjasper-dev libqtgui4 libqt4-test protobuf-compiler python3-opencv gpsd gpsd-clients","title":"Download datafile"},{"location":"car-park/#activate-a-virtual-environment","text":"pip3 install virtualenv ./run_scripts/create_venv.sh source venv/bin/activate","title":"Activate a virtual environment."},{"location":"car-park/#install-the-software","text":"python setup.py develop Note We recommend that using develop as this creates a link to the code and so any changes you make will take immediate effect when you run the code.","title":"Install the software"},{"location":"car-park/#run-it","text":"./run_scripts/run_carpark_agent.sh You should now see the agent running.","title":"Run it"},{"location":"car-park/#ensure-agent-start-on-boot-rpi4-only","text":"Ensure the startup script runs whenever we the Raspberry Pi turns on. crontab -e Pick an editor which will open a text file. Scroll to the bottom and add the following line. @reboot /home/pi/Desktop/carpark_agent/run_scripts/run_carpark_agent.sh Save and reboot. The agent should now start automatically on reboot.","title":"Ensure agent start on boot (RPi4 only)"},{"location":"car-park/#get-the-pis-ip-address","text":"We will need the ip address of the Raspberry Pi to connect remotely. ifconfig Returns something like: ... wlan0: flags = 4163 <UP,BROADCAST,RUNNING,MULTICAST> mtu 1500 inet 192 .168.11.9 netmask 255 .255.255.0 broadcast 192 .168.11.255 ... The inet value is the Raspberry Pi's ip address.","title":"Get the Pi's ip address"},{"location":"car-park/#connect-to-the-app-remotely","text":"Download and install the VNC viewer onto your remote laptop: https://www.realvnc.com/en/connect/download/viewer/ . Add the Pi's ip address. You will be prompted for the Raspberry Pi password. The Raspberry Pi's desktop should appear.","title":"Connect to the app remotely"},{"location":"car-park/#get-your-remote-desktop-ip","text":"Follow the instructiona to get your remote ip address.","title":"Get your remote desktop ip"},{"location":"car-park/#connect-to-the-raspberry-pi","text":"Start up the agent, if it is not running - but it should be. cd Desktop/carpark_agent ./run_scripts/run_carpark_agent.sh","title":"Connect to the Raspberry Pi"},{"location":"car-park/#stopped-here-monday-28th-october","text":"","title":"STOPPED HERE - Monday 28th October"},{"location":"car-park/#the-pi-server-app-instructions-come-next","text":"From \"When it starts up and you see the output from the camera, you can move your camera around so it is looking at the area...","title":"The Pi server app instructions come next"},{"location":"cli-commands/","text":"CLI commands Command Description add connection/protocol/skill [name] Add connection, protocol, or skill, called [name] , to the agent. create NAME Create a new aea project called [name] . delete NAME Delete an aea project. See below for disabling a resource. fetch NAME Fetch an aea project called [name] . freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key default/fetchai/ethereum/all Generate private keys. install [-r <requirements_file>] Install the dependencies. list protocols/connections/skills List the installed resources. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from agent. run {using [connection, ...]} Run the agent on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"Commands"},{"location":"cli-commands/#cli-commands","text":"Command Description add connection/protocol/skill [name] Add connection, protocol, or skill, called [name] , to the agent. create NAME Create a new aea project called [name] . delete NAME Delete an aea project. See below for disabling a resource. fetch NAME Fetch an aea project called [name] . freeze Get all the dependencies needed for the aea project and its components. gui Run the GUI. generate-key default/fetchai/ethereum/all Generate private keys. install [-r <requirements_file>] Install the dependencies. list protocols/connections/skills List the installed resources. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from agent. run {using [connection, ...]} Run the agent on the Fetch.ai network with default or specified connections. search protocols/connections/skills Search for components in the registry. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"CLI commands"},{"location":"cli-gui/","text":"The AEA Command Line Interface (CLI) can also be invoked from a Graphical User Interface (GUI) which can be access from a web browser. These instructions will take you through building an agent, starting an OEF Node and running the agent - all from the GUI. Once you can do this, the other operations should be fairly self-explanatory. Preliminaries Ensure you have the framework installed and the CLI is working by following the quick-start guide . Please install the extra dependencies for the CLI GUI: pip install aea [ cli_gui ] Starting the GUI Go to your working folder, where you want to create new agents. If you followed the quick start guide, this will be in the my_aea directory. Start the local web-server: aea gui Open this page in a browser: http://127.0.0.1:8080 You should see the following page displayed: On the left-hand side we can see any agents you have created and any protocols, connections and skills they have. Initially this will be empty - or if you have created an agent using the CLI in the quick-start guide and not deleted it then that should be listed. On the right-hand side is the Registry which shows all the protocols, connections and skills which are available to you to construct your agents out of. To create a new agent and run it, follow these steps: In the [Create Agent id] box on the left. type the name of your agent - e.g. my_new_agent. This should now be the currently selected agent - but you can click on its name in the list to make sure. Click the [Create Agent] button - the newly created agent should appear in the [Local Agents] table On the right hand side, find the Echo skill and click on it - this will select it Click on the [Add skill] button - which should actually now say \"Add echo skill to my_new_agent agent\" Start an OEF Node, by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. This shows that the node has started successfully Start the agent running, by clicking on the [start agent] button - you should see the output from the echo agent appearing on the screen This is how your whole page should look if you followed the instructions correctly","title":"GUI"},{"location":"cli-gui/#preliminaries","text":"Ensure you have the framework installed and the CLI is working by following the quick-start guide . Please install the extra dependencies for the CLI GUI: pip install aea [ cli_gui ]","title":"Preliminaries"},{"location":"cli-gui/#starting-the-gui","text":"Go to your working folder, where you want to create new agents. If you followed the quick start guide, this will be in the my_aea directory. Start the local web-server: aea gui Open this page in a browser: http://127.0.0.1:8080 You should see the following page displayed: On the left-hand side we can see any agents you have created and any protocols, connections and skills they have. Initially this will be empty - or if you have created an agent using the CLI in the quick-start guide and not deleted it then that should be listed. On the right-hand side is the Registry which shows all the protocols, connections and skills which are available to you to construct your agents out of. To create a new agent and run it, follow these steps: In the [Create Agent id] box on the left. type the name of your agent - e.g. my_new_agent. This should now be the currently selected agent - but you can click on its name in the list to make sure. Click the [Create Agent] button - the newly created agent should appear in the [Local Agents] table On the right hand side, find the Echo skill and click on it - this will select it Click on the [Add skill] button - which should actually now say \"Add echo skill to my_new_agent agent\" Start an OEF Node, by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. This shows that the node has started successfully Start the agent running, by clicking on the [start agent] button - you should see the output from the echo agent appearing on the screen This is how your whole page should look if you followed the instructions correctly","title":"Starting the GUI"},{"location":"cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"CLI tool"},{"location":"cli-how-to/#installation","text":"The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"Installation"},{"location":"connection/","text":"A Connection is attached to a MailBox within the AEA framework. The connection.py module in the connections directory contains two classes. A Connection object has a reference to a Channel . Channel : a wrapper for an SDK or API. Connection : a proxy to the functionality of an SDK or API. Configuration The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.ai Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of both Connection and Channel classes dependent on the protocol type. Channel send(self, envelope: Envelope) connect(self) -> Optional[Queue] disconnect(self) Connection is_established(self) connect(self) disconnect(self) send(self, envelope: Envelope) from_config(cls, public_key: str, connection_configuration: ConnectionConfig) Launching oef connections oef - local node Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection. oef - remote node Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"Connection"},{"location":"connection/#configuration","text":"The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.ai Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of both Connection and Channel classes dependent on the protocol type.","title":"Configuration"},{"location":"connection/#channel","text":"","title":"Channel"},{"location":"connection/#sendself-envelope-envelope","text":"","title":"send(self, envelope: Envelope)"},{"location":"connection/#connectself-gt-optionalqueue","text":"","title":"connect(self) -&gt; Optional[Queue]"},{"location":"connection/#disconnectself","text":"","title":"disconnect(self)"},{"location":"connection/#connection","text":"","title":"Connection"},{"location":"connection/#is_establishedself","text":"","title":"is_established(self)"},{"location":"connection/#connectself","text":"","title":"connect(self)"},{"location":"connection/#disconnectself_1","text":"","title":"disconnect(self)"},{"location":"connection/#sendself-envelope-envelope_1","text":"","title":"send(self, envelope: Envelope)"},{"location":"connection/#from_configcls-public_key-str-connection_configuration-connectionconfig","text":"","title":"from_config(cls, public_key: str, connection_configuration: ConnectionConfig)"},{"location":"connection/#launching-oef-connections","text":"","title":"Launching oef connections"},{"location":"connection/#oef-local-node","text":"Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection.","title":"oef - local node"},{"location":"connection/#oef-remote-node","text":"Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"oef - remote node"},{"location":"core-components/","text":"MailBox A MailBox contains InBox and OutBox queues containing Envelopes . Envelope An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Protocol Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept . Connection Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains two abstract classes which define a Channel and a Connection . A Connection contains one Channel , which acts as a bridge to the SDK or API to be wrapped. The Channel is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK. Skill Skills are a result of the framework's extensibility. They are atomic capabilities that agents can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the agent, and suggest action(s) to the agent according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the agent the best course of actions to take. For instance, an agent who is playing chess, could subscribe to more than one skill, where each skill corresponds to a specific strategy for playing chess. The skills could then read the internal state of the agent, including the agent's observation of the game's state, and suggest a next move to the agent. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement agents' reactive behaviour. If the agent understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement agents' proactiveness. Task : none, one or more Tasks encapsulate background work internal to the agent. Agent Main loop The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them. Decision maker The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the agent's crypto-economic security and goal management, and it contains the preference and ownership representation of the agent. Filter Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-register and re-register themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills. Resource The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Core components"},{"location":"core-components/#mailbox","text":"A MailBox contains InBox and OutBox queues containing Envelopes .","title":"MailBox"},{"location":"core-components/#envelope","text":"An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form.","title":"Envelope"},{"location":"core-components/#protocol","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept .","title":"Protocol"},{"location":"core-components/#connection","text":"Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains two abstract classes which define a Channel and a Connection . A Connection contains one Channel , which acts as a bridge to the SDK or API to be wrapped. The Channel is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK.","title":"Connection"},{"location":"core-components/#skill","text":"Skills are a result of the framework's extensibility. They are atomic capabilities that agents can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the agent, and suggest action(s) to the agent according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the agent the best course of actions to take. For instance, an agent who is playing chess, could subscribe to more than one skill, where each skill corresponds to a specific strategy for playing chess. The skills could then read the internal state of the agent, including the agent's observation of the game's state, and suggest a next move to the agent. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement agents' reactive behaviour. If the agent understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement agents' proactiveness. Task : none, one or more Tasks encapsulate background work internal to the agent.","title":"Skill"},{"location":"core-components/#agent","text":"","title":"Agent"},{"location":"core-components/#main-loop","text":"The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them.","title":"Main loop"},{"location":"core-components/#decision-maker","text":"The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the agent's crypto-economic security and goal management, and it contains the preference and ownership representation of the agent.","title":"Decision maker"},{"location":"core-components/#filter","text":"Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-register and re-register themselves. The Filter also routes internal messages from the DecisionMaker to the respective Handler in the skills.","title":"Filter"},{"location":"core-components/#resource","text":"The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Resource"},{"location":"design-principles/","text":"We have collated 8 principles which guide AEA framework development: Accessibility : easy of use. Modularity : encourages module creation and sharing and reuse. Openness : easily extensible with third party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"diagram/","text":"Note Work in progress. The framework can be divided into two parts: a) a core part that is developed by the Fetch.ai team as well as external contributors, and b) extensions (also known as packages ) developed by any developer. This allows for a modular and scalable framework. Currently, the framework supports three types of packages which can be added to the core part as modules: Skills Protocols Connections The following figure illustrates the framework's architecture:","title":"Architectural diagram"},{"location":"file-structure/","text":"The file structure of an agent is fixed. The top level directory has the agent's name. Below is a yaml configuration file, then directories containing the connections, protocols, and skills, and a file containing the private key of the agent. The developer can create new directories where necessary but the core structure must remain the same. The CLI tool provides a way to scaffold out the required directory structure for new agents. See the instructions for that here . agent_name/ aea-config.yaml YAML configuration of the agent private_key.pem The private key file connections/ Directory containing all the supported connections connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all supported protocols protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skill components skill_1/ First skill ... ... skill_k/ kth skill","title":"File structure"},{"location":"fipa-skill/","text":"Note Work in progress. The AEA FIPA skill demonstrates how FIPA negotiation strategies may be embedded into an Autonomous Economic Agent. Configuration The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled. Shared classes The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill. Search This class abstracts the logic required by agents performing searches for other buying/selling agents according to strategy (see below). Strategy This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether the agent intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not. Dialogue Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between. Transactions This class deals with representing potential transactions between agents. Demo instructions Warn FIPA negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the FIPA agent. aea create my_fipa_agent Add the FIPA skill cd my_fipa_agent aea add skill fipa_negotiation Add the local connection aea add connection local Run the agent with the default connection aea run --connection local Delete the agent When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"Fipa skill"},{"location":"fipa-skill/#configuration","text":"The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled.","title":"Configuration"},{"location":"fipa-skill/#shared-classes","text":"The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill.","title":"Shared classes"},{"location":"fipa-skill/#search","text":"This class abstracts the logic required by agents performing searches for other buying/selling agents according to strategy (see below).","title":"Search"},{"location":"fipa-skill/#strategy","text":"This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether the agent intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not.","title":"Strategy"},{"location":"fipa-skill/#dialogue","text":"Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between.","title":"Dialogue"},{"location":"fipa-skill/#transactions","text":"This class deals with representing potential transactions between agents.","title":"Transactions"},{"location":"fipa-skill/#demo-instructions","text":"Warn FIPA negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"fipa-skill/#create-the-agent","text":"In the root directory, create the FIPA agent. aea create my_fipa_agent","title":"Create the agent"},{"location":"fipa-skill/#add-the-fipa-skill","text":"cd my_fipa_agent aea add skill fipa_negotiation","title":"Add the FIPA skill"},{"location":"fipa-skill/#add-the-local-connection","text":"aea add connection local","title":"Add the local connection"},{"location":"fipa-skill/#run-the-agent-with-the-default-connection","text":"aea run --connection local","title":"Run the agent with the default connection"},{"location":"fipa-skill/#delete-the-agent","text":"When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"Delete the agent"},{"location":"gym-plugin/","text":"The gym_ex example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning. There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate environments, potentially owned by different entities. Quick start Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Packages Install the following packages. pip install numpy gym Files If you haven't done so already, download the examples and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym demo"},{"location":"gym-plugin/#quick-start","text":"","title":"Quick start"},{"location":"gym-plugin/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"gym-plugin/#packages","text":"Install the following packages. pip install numpy gym","title":"Packages"},{"location":"gym-plugin/#files","text":"If you haven't done so already, download the examples and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Files"},{"location":"gym-plugin/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses openai's gym library, may be embedded into an Autonomous Economic Agent. Demo instructions Follow the Preliminaries and Installation instructions here . Install the gym library. pip install gym Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the gym agent. aea create my_gym_agent Add the gym skill cd my_gym_agent aea add skill gym Copy the gym environment to the agent directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Add a gym connection aea add connection gym Update the connection config nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom Run the agent with the gym connection aea run --connection gym You will see the gym training logs. Delete the agent When you're done, you can go up a level and delete the agent. aea delete my_gym_agent","title":"Gym skill"},{"location":"gym-skill/#demo-instructions","text":"Follow the Preliminaries and Installation instructions here . Install the gym library. pip install gym Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"gym-skill/#create-the-agent","text":"In the root directory, create the gym agent. aea create my_gym_agent","title":"Create the agent"},{"location":"gym-skill/#add-the-gym-skill","text":"cd my_gym_agent aea add skill gym","title":"Add the gym skill"},{"location":"gym-skill/#copy-the-gym-environment-to-the-agent-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the agent directory"},{"location":"gym-skill/#add-a-gym-connection","text":"aea add connection gym","title":"Add a gym connection"},{"location":"gym-skill/#update-the-connection-config","text":"nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom","title":"Update the connection config"},{"location":"gym-skill/#run-the-agent-with-the-gym-connection","text":"aea run --connection gym You will see the gym training logs.","title":"Run the agent with the gym connection"},{"location":"gym-skill/#delete-the-agent","text":"When you're done, you can go up a level and delete the agent. aea delete my_gym_agent","title":"Delete the agent"},{"location":"hacking-an-agent/","text":"Warning Not recommended. Note Coming soon.","title":"Code an agent directly"},{"location":"integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third party ledgers. Fetch.ai Ledger Note Coming soon. Ethereum Ledger Note Coming soon.","title":"Integrate with third parties"},{"location":"integration/#fetchai-ledger","text":"Note Coming soon.","title":"Fetch.ai Ledger"},{"location":"integration/#ethereum-ledger","text":"Note Coming soon.","title":"Ethereum Ledger"},{"location":"logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we will configure logging for an agent. First of all, create your agent: aea create my_agent cd my_agent The aea-config.yaml file should look like: aea_version : 0.1.6 agent_name : my_agent authors : '' connections : - oef default_connection : oef license : '' private_key_pem_path : '' protocols : - default registry_path : ../packages skills : - error url : '' version : v1 logging_config : disable_existing_loggers : false version : 1 By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. An example of logging_config value is reported below: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : true This configuration will set up a logger with name aea , print both on console (see console handler) and on file (see logfile handler) with format specified by the standard formatter.","title":"Logging"},{"location":"oef-ledger/","text":"In the AEA framework universe, agents run alongside OEF search and discovery nodes against the Fetch.ai ledger and external ledger systems.","title":"Relation to OEF and Ledger"},{"location":"protocol/","text":"A Protocol manages message representation, encoding, and serialisation. It also defines the rules to which messages must adhere. An agent can have one or more protocols. The AEA framework supplies three: oef , fipa , and a default protocol. Custom protocol For a custom protocol, the developer must code methods from two classes. Message.check_consistency(self) This method checks the message data for consistency and raises an error if necessary. Todo For example. Serializer.encode(self, msg: Message) This method encodes a message object into bytes for passing around. Todo For example. Serializer.decode(self, obj: bytes) This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way they see fit. rules.py Note Coming soon. oef protocol The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc. fipa protocol The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Peformative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } } default protocol The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"Protocol"},{"location":"protocol/#custom-protocol","text":"For a custom protocol, the developer must code methods from two classes.","title":"Custom protocol"},{"location":"protocol/#messagecheck_consistencyself","text":"This method checks the message data for consistency and raises an error if necessary. Todo For example.","title":"Message.check_consistency(self)"},{"location":"protocol/#serializerencodeself-msg-message","text":"This method encodes a message object into bytes for passing around. Todo For example.","title":"Serializer.encode(self, msg: Message)"},{"location":"protocol/#serializerdecodeself-obj-bytes","text":"This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way they see fit.","title":"Serializer.decode(self, obj: bytes)"},{"location":"protocol/#rulespy","text":"Note Coming soon.","title":"rules.py"},{"location":"protocol/#oef-protocol","text":"The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc.","title":"oef protocol"},{"location":"protocol/#fipa-protocol","text":"The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Peformative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } }","title":"fipa protocol"},{"location":"protocol/#default-protocol","text":"The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"default protocol"},{"location":"quickstart/","text":"Preliminaries Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell At some point, you will need Docker installed on your machine (e.g. to run an OEF Node). If you don't have it, please check the official documentation here and follow the instructions for your platform. Installation Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA, including the CLI (Command Line Interface) extension, alone. pip install aea [ cli ] Known issues If the installation steps fail, it might be because some of the dependencies cannot be built on your system. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers sudo apt-get install python3.7-dev Windows users: install build tools for Visual Studio . Echo skill demo The echo skill is a simple demo that introduces you to the main business logic components of an AEA. Download the scripts and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create a new agent First create a new agent project and enter it. aea create my_first_agent cd my_first_agent Add the echo skill aea add skill echo This copies the echo application code for the behaviours, handlers, and tasks into the skill, ready to run. Add a stub connection AEAs use messages for communication. We will add a stub connection to send messages to and receive messages from the AEA. aea add connection stub A stub connection provides an I/O reader/writer. It uses two files for communication: one for the incoming messages and the other for the outgoing messages. Each line contains an encoded envelope. The AEA waits for new messages posted to the file my_first_agent/input_file , and adds a response to the file my_first_agent/output_file . The format of each line is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE For example: recipient_agent,sender_agent,default, { \"type\" : \"bytes\" , \"content\" : \"aGVsbG8=\" } Run the agent Run the agent with the stub connection. aea run --connection stub You will see the echo task running in the terminal window. The framework first calls the setup method on the Handler , Behaviour , and Task code in that order; after which it repeatedly calls the Behaviour and Task methods, act and execute . This is the main agent loop in action. Let's look at the Handler in more depth. Add a message to the input file We send the AEA a message wrapped in an envelope via the input file. echo 'my_first_agent,sender_agent,default,{\"type\": \"bytes\", \"content\": \"aGVsbG8=\"}' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( type = bytes content = b 'hello' ) , sender = sender_agent info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called. Stop the agent Stop the agent by pressing CTRL C Delete the agent Delete the agent from the parent directory via cd .. . aea delete my_first_agent","title":"AEA quick start"},{"location":"quickstart/#preliminaries","text":"Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell At some point, you will need Docker installed on your machine (e.g. to run an OEF Node). If you don't have it, please check the official documentation here and follow the instructions for your platform.","title":"Preliminaries"},{"location":"quickstart/#installation","text":"Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA, including the CLI (Command Line Interface) extension, alone. pip install aea [ cli ]","title":"Installation"},{"location":"quickstart/#known-issues","text":"If the installation steps fail, it might be because some of the dependencies cannot be built on your system. The following hints can help: Ubuntu/Debian systems only: install Python 3.7 headers sudo apt-get install python3.7-dev Windows users: install build tools for Visual Studio .","title":"Known issues"},{"location":"quickstart/#echo-skill-demo","text":"The echo skill is a simple demo that introduces you to the main business logic components of an AEA.","title":"Echo skill demo"},{"location":"quickstart/#download-the-scripts-and-packages-directories","text":"svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Download the scripts and packages directories."},{"location":"quickstart/#create-a-new-agent","text":"First create a new agent project and enter it. aea create my_first_agent cd my_first_agent","title":"Create a new agent"},{"location":"quickstart/#add-the-echo-skill","text":"aea add skill echo This copies the echo application code for the behaviours, handlers, and tasks into the skill, ready to run.","title":"Add the echo skill"},{"location":"quickstart/#add-a-stub-connection","text":"AEAs use messages for communication. We will add a stub connection to send messages to and receive messages from the AEA. aea add connection stub A stub connection provides an I/O reader/writer. It uses two files for communication: one for the incoming messages and the other for the outgoing messages. Each line contains an encoded envelope. The AEA waits for new messages posted to the file my_first_agent/input_file , and adds a response to the file my_first_agent/output_file . The format of each line is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE For example: recipient_agent,sender_agent,default, { \"type\" : \"bytes\" , \"content\" : \"aGVsbG8=\" }","title":"Add a stub connection"},{"location":"quickstart/#run-the-agent","text":"Run the agent with the stub connection. aea run --connection stub You will see the echo task running in the terminal window. The framework first calls the setup method on the Handler , Behaviour , and Task code in that order; after which it repeatedly calls the Behaviour and Task methods, act and execute . This is the main agent loop in action. Let's look at the Handler in more depth.","title":"Run the agent"},{"location":"quickstart/#add-a-message-to-the-input-file","text":"We send the AEA a message wrapped in an envelope via the input file. echo 'my_first_agent,sender_agent,default,{\"type\": \"bytes\", \"content\": \"aGVsbG8=\"}' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( type = bytes content = b 'hello' ) , sender = sender_agent info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called. info: Echo Behaviour: act method called. info: Echo Task: execute method called.","title":"Add a message to the input file"},{"location":"quickstart/#stop-the-agent","text":"Stop the agent by pressing CTRL C","title":"Stop the agent"},{"location":"quickstart/#delete-the-agent","text":"Delete the agent from the parent directory via cd .. . aea delete my_first_agent","title":"Delete the agent"},{"location":"scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml . Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a connection aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffolding"},{"location":"scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml .","title":"Scaffold generator"},{"location":"scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffold a connection"},{"location":"skill-guide/","text":"The scaffolding tool allows you create the folder structure required for a skill. Note Before developing your first skill, please read the skill guide . Step 1: Setup Ensure, you have followed the preliminaries and installation . We will first create an agent and add a scaffold skill, which we call my_search : aea create my_agent && cd my_agent aea scaffold skill my_search In the following steps, we will replace each one of the scaffolded Behaviour , Handler and Task in my_agent/skills/my_search with our implementation. We will build a simple skill which lets the agent send a search query to the OEF and process the resulting response. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF. import logging import time from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.models import Query , Constraint , ConstraintType from aea.protocols.oef.serialization import DEFAULT_OEF , OEFSerializer from aea.skills.base import Behaviour logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchBehaviour ( Behaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchBehaviour\" . format ( self . context . agent_name )) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" time . sleep ( 1 ) # to slow down the agent self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OEFMessage ( oef_type = OEFMessage . Type . SEARCH_SERVICES , id = self . sent_search_count , query = search_query_w_empty_model ) logger . info ( \"[{}]: sending search request to OEF, search_count={}\" . format ( self . context . agent_name , self . sent_search_count )) self . context . outbox . put_message ( to = DEFAULT_OEF , sender = self . context . agent_address , protocol_id = OEFMessage . protocol_id , message = OEFSerializer () . encode ( search_request )) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchBehaviour\" . format ( self . context . agent_name )) Searches are proactive and as such well placed in a Behaviour . We place this code in my_agent/skills/my_search/behaviours.py . Step 3: Develop a Handler So far, we have tasked the agent with sending search requests to the OEF. However, we have no way of handling the responses sent to the agent by the OEF at the moment. The agent would simply respond to the OEF via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. import logging from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.serialization import OEFSerializer from aea.skills.base import Handler logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OEFMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" logger . info ( \"[{}]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OEFMessage , sender : str ) -> None : \"\"\" Handle the message. :param message: the message. :param sender: the sender. :return: None \"\"\" msg_type = OEFMessage . Type ( message . get ( \"type\" )) if msg_type is OEFMessage . Type . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) logger . info ( \"[{}]: found number of agents={}, received search count={}\" . format ( self . context . agent_name , nb_agents_found , self . received_search_count )) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchHandler\" . format ( self . context . agent_name )) We create a handler which is registered for the oef protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. We place this code in my_agent/skills/my_search/handlers.py . Step 4: Develop a Task We have implemented a behaviour and a handler. We conclude by implementing a task. Here we can implement background logic. We will implement a trivial check on the difference between the amount of search requests sent and responses received. import logging from aea.skills.base import Task logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchTask ( Task ): \"\"\"This class scaffolds a task.\"\"\" def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchTask\" . format ( self . context . agent_name )) def execute ( self ) -> None : \"\"\" Implement the task execution. :param envelope: the envelope :return: None \"\"\" my_search_behaviour = self . context . behaviours [ 0 ] my_search_handler = self . context . handlers [ 0 ] logger . info ( \"[{}]: number of search requests sent={} vs. number of search responses received={}\" . format ( self . context . agent_name , my_search_behaviour . sent_search_count , my_search_handler . received_search_count ) ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchTask\" . format ( self . context . agent_name )) Note, how we have access to other objects in the skill via self.context . We place this code in my_agent/skills/my_search/tasks.py . Step 5: Create the config file Based on our skill components above, we create the following config file: name : my_search authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" description : 'A simple search skill utilising the OEF.' behaviours : - behaviour : class_name : MySearchBehaviour args : {} handlers : - handler : class_name : MySearchHandler args : {} tasks : - task : class_name : MySearchTask args : {} shared_classes : [] protocols : [ \"oef\" ] dependencies : [] We place this code in my_agent/skills/my_search/skill.yaml . Step 6: Add the oef protocol Our agent does not have the oef protocol yet. Hence, we add it like so: aea add protocol oef Step 7: Run the agent We first start an oef node (see the connection section for more details) in a separate terminal window: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json We can then launch our agent: aea run Stop the agent with CTRL + C . Now it's your turn: We hope this step by step introduction has helped you to develop your own skill. We are excited to see what you will build.","title":"Build your own skill"},{"location":"skill-guide/#step-1-setup","text":"Ensure, you have followed the preliminaries and installation . We will first create an agent and add a scaffold skill, which we call my_search : aea create my_agent && cd my_agent aea scaffold skill my_search In the following steps, we will replace each one of the scaffolded Behaviour , Handler and Task in my_agent/skills/my_search with our implementation. We will build a simple skill which lets the agent send a search query to the OEF and process the resulting response.","title":"Step 1: Setup"},{"location":"skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF. import logging import time from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.models import Query , Constraint , ConstraintType from aea.protocols.oef.serialization import DEFAULT_OEF , OEFSerializer from aea.skills.base import Behaviour logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchBehaviour ( Behaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchBehaviour\" . format ( self . context . agent_name )) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" time . sleep ( 1 ) # to slow down the agent self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OEFMessage ( oef_type = OEFMessage . Type . SEARCH_SERVICES , id = self . sent_search_count , query = search_query_w_empty_model ) logger . info ( \"[{}]: sending search request to OEF, search_count={}\" . format ( self . context . agent_name , self . sent_search_count )) self . context . outbox . put_message ( to = DEFAULT_OEF , sender = self . context . agent_address , protocol_id = OEFMessage . protocol_id , message = OEFSerializer () . encode ( search_request )) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchBehaviour\" . format ( self . context . agent_name )) Searches are proactive and as such well placed in a Behaviour . We place this code in my_agent/skills/my_search/behaviours.py .","title":"Step 2: Develop a Behaviour"},{"location":"skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the agent with sending search requests to the OEF. However, we have no way of handling the responses sent to the agent by the OEF at the moment. The agent would simply respond to the OEF via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. import logging from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.serialization import OEFSerializer from aea.skills.base import Handler logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OEFMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" logger . info ( \"[{}]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OEFMessage , sender : str ) -> None : \"\"\" Handle the message. :param message: the message. :param sender: the sender. :return: None \"\"\" msg_type = OEFMessage . Type ( message . get ( \"type\" )) if msg_type is OEFMessage . Type . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) logger . info ( \"[{}]: found number of agents={}, received search count={}\" . format ( self . context . agent_name , nb_agents_found , self . received_search_count )) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchHandler\" . format ( self . context . agent_name )) We create a handler which is registered for the oef protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. We place this code in my_agent/skills/my_search/handlers.py .","title":"Step 3: Develop a Handler"},{"location":"skill-guide/#step-4-develop-a-task","text":"We have implemented a behaviour and a handler. We conclude by implementing a task. Here we can implement background logic. We will implement a trivial check on the difference between the amount of search requests sent and responses received. import logging from aea.skills.base import Task logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchTask ( Task ): \"\"\"This class scaffolds a task.\"\"\" def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchTask\" . format ( self . context . agent_name )) def execute ( self ) -> None : \"\"\" Implement the task execution. :param envelope: the envelope :return: None \"\"\" my_search_behaviour = self . context . behaviours [ 0 ] my_search_handler = self . context . handlers [ 0 ] logger . info ( \"[{}]: number of search requests sent={} vs. number of search responses received={}\" . format ( self . context . agent_name , my_search_behaviour . sent_search_count , my_search_handler . received_search_count ) ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchTask\" . format ( self . context . agent_name )) Note, how we have access to other objects in the skill via self.context . We place this code in my_agent/skills/my_search/tasks.py .","title":"Step 4: Develop a Task"},{"location":"skill-guide/#step-5-create-the-config-file","text":"Based on our skill components above, we create the following config file: name : my_search authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" description : 'A simple search skill utilising the OEF.' behaviours : - behaviour : class_name : MySearchBehaviour args : {} handlers : - handler : class_name : MySearchHandler args : {} tasks : - task : class_name : MySearchTask args : {} shared_classes : [] protocols : [ \"oef\" ] dependencies : [] We place this code in my_agent/skills/my_search/skill.yaml .","title":"Step 5: Create the config file"},{"location":"skill-guide/#step-6-add-the-oef-protocol","text":"Our agent does not have the oef protocol yet. Hence, we add it like so: aea add protocol oef","title":"Step 6: Add the oef protocol"},{"location":"skill-guide/#step-7-run-the-agent","text":"We first start an oef node (see the connection section for more details) in a separate terminal window: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json We can then launch our agent: aea run Stop the agent with CTRL + C .","title":"Step 7: Run the agent"},{"location":"skill-guide/#now-its-your-turn","text":"We hope this step by step introduction has helped you to develop your own skill. We are excited to see what you will build.","title":"Now it's your turn:"},{"location":"skill/","text":"An agent developer writes skills that the framework can call. When you add a skill with the CLI, a directory is created which includes modules for the Behaviour, Task , and Handler classes as well as a configuration file skill.yaml . Context The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the agent context. The agent context provides read access to agent specific information like the public key and address of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example. behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example. tasks.py Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example. Shared classes The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class Skill config Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ] Error skill All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the default protocol which provides error codes for the above.","title":"Skill"},{"location":"skill/#context","text":"The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the agent context. The agent context provides read access to agent specific information like the public key and address of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example.","title":"handlers.py"},{"location":"skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example.","title":"behaviours.py"},{"location":"skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example.","title":"tasks.py"},{"location":"skill/#shared-classes","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class","title":"Shared classes"},{"location":"skill/#skill-config","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.ai Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ]","title":"Skill config"},{"location":"skill/#error-skill","text":"All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the default protocol which provides error codes for the above.","title":"Error skill"},{"location":"steps/","text":"There are a number of ways to build an agent. We recommended you build an AEA project with the CLI tool as mentioned in the quick start guide. See information on the CLI tool here . [Coming soon!] Using the CLI fetch command, pull in an already built project and run as normal. The last option is to install the AEA without the CLI tool with pip install aea and, from there, import classes directly. Set up your skills . Code the protocols . Add the connections . Scaffold any of the above resources with the scaffolding tool . This guide shows you step by step how to develop a skill. Now, build and run your agent using the quick start guide .","title":"Step by step"},{"location":"tac-skill/","text":"Todo","title":"Tac skill"},{"location":"tac/","text":"TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include submodules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Launcher GUI Todo Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"tac/#quick-start","text":"Clone the repo to include submodules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"tac/#launcher-gui","text":"Todo","title":"Launcher GUI"},{"location":"tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"transport/","text":"Todo","title":"Transport"},{"location":"trust/","text":"AEA applications operate within different orders of trustlessness. For example, using the AEA weather skills demo without a ledger means that clients must trust the weather station that any data it sends is sufficient, including no data at all. Similarly, the weather station must trust the weather clients to send payment via some mechanism. A step up, if you run the weather skills demo with a ledger (Fetch.ai or Ethereum) then the clients must again trust the weather station to send sufficient data. However, all payment transactions are executed via the public ledger. And so the weather station must no longer trust the weather clients as it can observe the transaction taking place on the public ledger. One could expand trustlessness even further by incorporating a third party as an arbitrator or some escrow contract. However, in the weather skills demo there are limits to trustlessness as the station ultimately offers unverifiable data. Finally, in the case of (non-fungible) token transactions where there is an atomic swap, full trustlessness is apparent. This is demonstrated in the TAC.","title":"Trust issues"},{"location":"two-layer/","text":"Todo","title":"Two layer"},{"location":"version/","text":"The current version of the Autonomous Economic Agent framework is 0.1.x . The framework is under rapid development with frequent breaking changes.","title":"Version"},{"location":"vision/","text":"The AEA framework has two commercial roles. Open source technology We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers. Platform for start ups By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Vision"},{"location":"vision/#open-source-technology","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists. Economists. Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems). Engineers. Machine learning experts. Independent developers. Students and academics. Crypto connoisseurs and enthusiasts. Web developers.","title":"Open source technology"},{"location":"vision/#platform-for-start-ups","text":"By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Platform for start ups"},{"location":"weather-skills/","text":"The AEA weather skills demonstrate an interaction between two AEAs; one as the provider of weather data (the weather station), the other as the seller of weather data (the weather client). Prerequisites Make sure you have the latest aea version. aea --version If not, update with the following. pip install aea [ all ] --force --no-cache-dir Demo preliminaries Follow the Preliminaries and Installation instructions here . Download the packages and scripts directories. svn export https://github.com/fetchai/agents-aea.git/trunk/packages svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Launch the OEF Node (for search and discovery): In a separate terminal, launch an OEF node locally: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos. Demo 1: no ledger payment The AEAs negotiate and then transfer the data. No payment takes place. This demo serves as a demonstration of the negotiation steps. Create the weather station AEA: In the root directory, create the weather station AEA. aea create my_weather_station Add the weather station skill cd my_weather_station aea add skill weather_station Run the weather station AEA aea run Create the weather client AEA In a new terminal window, return to the root directory and create the weather client AEA. aea create my_weather_client Add the weather client skill cd my_weather_client aea add skill weather_client Run the weather client AEA aea run Observe the logs of both AEAs Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Demo 2: Fetch.ai ledger payment A demo to run the same scenario but with a true ledger transaction on Fetch.ai test net. This demo assumes the weather client trusts the weather station to send the weather data upon successful payment. Create the weather station (ledger version) Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger Create the weather client (ledger version): In another terminal, create the AEA that will query the weather station aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA aea generate-key fetchai Update the AEA configs Both in weather_station/aea-config.yaml and weather_client/aea-config.yaml , replace ledger_apis: [] with: ledger_apis : - ledger_api : ledger : fetchai addr : alpha.fetch-ai.com port : 80 Fund the weather client AEA Create some wealth for your weather client on the Fetch.ai test net (it takes a while): cd .. python scripts/fetchai_wealth_generation.py --private-key weather_client/fet_private_key.txt --amount 10000000 --addr alpha.fetch-ai.com --port 80 cd my_weather_client Run the AEAs Run both AEAs, from their respective terminals aea run You will see that the AEAs negotiate and then transact using the Fetch.ai test net. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client Demo 3: Ethereum ledger payment A demo to run the same scenario but with a true ledger transaction on Fetch.ai test net. This demo assumes the weather client trusts the weather station to send the weather data upon successful payment. Create the weather station (ledger version) Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger Create the weather client (ledger version): In another terminal, create the AEA that will query the weather station aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA aea generate-key ethereum Update the AEA configs Both in weather_station/aea-config.yaml and weather_client/aea-config.yaml , replace ledger_apis: [] with: ledger_apis : - ledger_api : addr : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe ledger : ethereum port : 3 Update the skill configs In the weather station skill config ( my_weather_station/skills/weather_station_ledger/skill.yaml ) under strategy change the currency_pbk and ledger_id as follows: currency_pbk: 'ETH' ledger_id: 'ethereum' and under ledgers change to: ledgers: ['ethereum'] In the weather client skill config ( my_weather_client/skills/weather_client_ledger/skill.yaml ) under strategy change the currency_pbk and ledger_id as follows: max_buyer_tx_fee: 20000 currency_pbk: 'ETH' ledger_id: 'ethereum' and under ledgers change to: ledgers: ['ethereum'] Fund the weather client AEA Create some wealth for your weather client on the Ethereum Ropsten test net: Go to Metamask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at weather_client/eth_private_key.txt . Run the AEAs Run both AEAs, from their respective terminals aea run You will see that the AEAs negotiate and then transact using the Fetch.ai test net. Delete the AEAs When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Weather skills"},{"location":"weather-skills/#prerequisites","text":"Make sure you have the latest aea version. aea --version If not, update with the following. pip install aea [ all ] --force --no-cache-dir","title":"Prerequisites"},{"location":"weather-skills/#demo-preliminaries","text":"Follow the Preliminaries and Installation instructions here . Download the packages and scripts directories. svn export https://github.com/fetchai/agents-aea.git/trunk/packages svn export https://github.com/fetchai/agents-aea.git/trunk/scripts","title":"Demo preliminaries"},{"location":"weather-skills/#launch-the-oef-node-for-search-and-discovery","text":"In a separate terminal, launch an OEF node locally: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Keep it running for all the following demos.","title":"Launch the OEF Node (for search and discovery):"},{"location":"weather-skills/#demo-1-no-ledger-payment","text":"The AEAs negotiate and then transfer the data. No payment takes place. This demo serves as a demonstration of the negotiation steps.","title":"Demo 1: no ledger payment"},{"location":"weather-skills/#create-the-weather-station-aea","text":"In the root directory, create the weather station AEA. aea create my_weather_station","title":"Create the weather station AEA:"},{"location":"weather-skills/#add-the-weather-station-skill","text":"cd my_weather_station aea add skill weather_station","title":"Add the weather station skill"},{"location":"weather-skills/#run-the-weather-station-aea","text":"aea run","title":"Run the weather station AEA"},{"location":"weather-skills/#create-the-weather-client-aea","text":"In a new terminal window, return to the root directory and create the weather client AEA. aea create my_weather_client","title":"Create the weather client AEA"},{"location":"weather-skills/#add-the-weather-client-skill","text":"cd my_weather_client aea add skill weather_client","title":"Add the weather client skill"},{"location":"weather-skills/#run-the-weather-client-aea","text":"aea run","title":"Run the weather client AEA"},{"location":"weather-skills/#observe-the-logs-of-both-aeas","text":"","title":"Observe the logs of both AEAs"},{"location":"weather-skills/#delete-the-aeas","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"weather-skills/#demo-2-fetchai-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai test net. This demo assumes the weather client trusts the weather station to send the weather data upon successful payment.","title":"Demo 2: Fetch.ai ledger payment"},{"location":"weather-skills/#create-the-weather-station-ledger-version","text":"Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger","title":"Create the weather station (ledger version)"},{"location":"weather-skills/#create-the-weather-client-ledger-version","text":"In another terminal, create the AEA that will query the weather station aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA aea generate-key fetchai","title":"Create the weather client (ledger version):"},{"location":"weather-skills/#update-the-aea-configs","text":"Both in weather_station/aea-config.yaml and weather_client/aea-config.yaml , replace ledger_apis: [] with: ledger_apis : - ledger_api : ledger : fetchai addr : alpha.fetch-ai.com port : 80","title":"Update the AEA configs"},{"location":"weather-skills/#fund-the-weather-client-aea","text":"Create some wealth for your weather client on the Fetch.ai test net (it takes a while): cd .. python scripts/fetchai_wealth_generation.py --private-key weather_client/fet_private_key.txt --amount 10000000 --addr alpha.fetch-ai.com --port 80 cd my_weather_client","title":"Fund the weather client AEA"},{"location":"weather-skills/#run-the-aeas","text":"Run both AEAs, from their respective terminals aea run You will see that the AEAs negotiate and then transact using the Fetch.ai test net.","title":"Run the AEAs"},{"location":"weather-skills/#delete-the-aeas_1","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"},{"location":"weather-skills/#demo-3-ethereum-ledger-payment","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai test net. This demo assumes the weather client trusts the weather station to send the weather data upon successful payment.","title":"Demo 3: Ethereum ledger payment"},{"location":"weather-skills/#create-the-weather-station-ledger-version_1","text":"Create the AEA that will provide weather measurements. aea create my_weather_station cd my_weather_station aea add skill weather_station_ledger","title":"Create the weather station (ledger version)"},{"location":"weather-skills/#create-the-weather-client-ledger-version_1","text":"In another terminal, create the AEA that will query the weather station aea create my_weather_client cd my_weather_client aea add skill weather_client_ledger Additionally, create the private key for the weather client AEA aea generate-key ethereum","title":"Create the weather client (ledger version):"},{"location":"weather-skills/#update-the-aea-configs_1","text":"Both in weather_station/aea-config.yaml and weather_client/aea-config.yaml , replace ledger_apis: [] with: ledger_apis : - ledger_api : addr : https://ropsten.infura.io/v3/f00f7b3ba0e848ddbdc8941c527447fe ledger : ethereum port : 3","title":"Update the AEA configs"},{"location":"weather-skills/#update-the-skill-configs","text":"In the weather station skill config ( my_weather_station/skills/weather_station_ledger/skill.yaml ) under strategy change the currency_pbk and ledger_id as follows: currency_pbk: 'ETH' ledger_id: 'ethereum' and under ledgers change to: ledgers: ['ethereum'] In the weather client skill config ( my_weather_client/skills/weather_client_ledger/skill.yaml ) under strategy change the currency_pbk and ledger_id as follows: max_buyer_tx_fee: 20000 currency_pbk: 'ETH' ledger_id: 'ethereum' and under ledgers change to: ledgers: ['ethereum']","title":"Update the skill configs"},{"location":"weather-skills/#fund-the-weather-client-aea_1","text":"Create some wealth for your weather client on the Ethereum Ropsten test net: Go to Metamask Faucet and request some test ETH for the account your weather client AEA is using (you need to first load your AEAs private key into MetaMask). Your private key is at weather_client/eth_private_key.txt .","title":"Fund the weather client AEA"},{"location":"weather-skills/#run-the-aeas_1","text":"Run both AEAs, from their respective terminals aea run You will see that the AEAs negotiate and then transact using the Fetch.ai test net.","title":"Run the AEAs"},{"location":"weather-skills/#delete-the-aeas_2","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the AEAs"}]}