{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The AEA framework provides the infrastructure for creating autonomous economic agents (AEA). It is a Python-based development suite which equips developers with an efficient and easy to understand set of tools for building autonomous economic agents. The framework is super modular, easily extensible, and highly composable. The AEA framework attempts to make agent development as straightforward as web development using popular web frameworks. AEA definition An autonomous economic agent (AEA) is an intelligent agent whose goal is generating economic value for its owner. The AEA super power is their ability to autonomously acquire new skills. AEAs achieve their goals with the help of the Fetch.AI OEF and the Fetch.AI Ledger. Third party systems, such as Ethereum, may also allow AEA integration. As such, AEAs bridge web 2 and web 3. Our vision The AEA framework has two commercial roles. Open source technology We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students/Academics Crypto passionates Web developers Platform for start ups By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"What is the AEA framework?"},{"location":"#aea-definition","text":"An autonomous economic agent (AEA) is an intelligent agent whose goal is generating economic value for its owner. The AEA super power is their ability to autonomously acquire new skills. AEAs achieve their goals with the help of the Fetch.AI OEF and the Fetch.AI Ledger. Third party systems, such as Ethereum, may also allow AEA integration. As such, AEAs bridge web 2 and web 3.","title":"AEA definition"},{"location":"#our-vision","text":"The AEA framework has two commercial roles.","title":"Our vision"},{"location":"#open-source-technology","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users are, among others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students/Academics Crypto passionates Web developers","title":"Open source technology"},{"location":"#platform-for-start-ups","text":"By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base. Note This developer documentation is a work in progress. If you spot any errors please open an issue here .","title":"Platform for start ups"},{"location":"cli-commands/","text":"CLI commands Command Description create [name] Create a new aea project called [name] . fetch [name] Fetch an aea project called [name] . scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . add connection/protocol/skill [name] Add connection, protocol, or skill, called [name] , to the agent. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from agent. install [-r <requirements_file>] Install the dependencies. list protocols/connections/skills List the installed resources. search protocols/connections/skills Search for components in the registry. run {using [connection, ...]} Run the agent on the Fetch.AI network with default or specified connections. -v DEBUG run Run with debugging. delete [name] Delete an aea project. See below for disabling a resource. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"Commands"},{"location":"cli-commands/#cli-commands","text":"Command Description create [name] Create a new aea project called [name] . fetch [name] Fetch an aea project called [name] . scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill called [name] . add connection/protocol/skill [name] Add connection, protocol, or skill, called [name] , to the agent. remove connection/protocol/skill [name] Remove connection, protocol, or skill, called [name] , from agent. install [-r <requirements_file>] Install the dependencies. list protocols/connections/skills List the installed resources. search protocols/connections/skills Search for components in the registry. run {using [connection, ...]} Run the agent on the Fetch.AI network with default or specified connections. -v DEBUG run Run with debugging. delete [name] Delete an aea project. See below for disabling a resource. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"CLI commands"},{"location":"cli-gui/","text":"The AEA Command Line Interface (CLI) can also be invoked from a Graphical User Interface (GUI) which can be access from a web browser. These instructions will take you through building an agent, starting an OEF Node and running the agent - all from the GUI. Once you can do this, the other operations should be fairly self-explanatory. Preliminaries Ensure you have the framework installed and the CLI is working by following the quick-start guide . Starting the GUI Go to your working folder, where you want to create new agents. If you followed the quick start guide, this will be in the my_aea directory. Start the local web-server: aea gui Open this page in a browser: http://127.0.0.1:8080 You should see the following page displayed: On the left-hand side we can see any agents you have created and any protocols, connections and skills they have. Initially this will be empty - or if you have created an agent using the CLI in the quick-start guide and not deleted it then that should be listed. On the right-hand side is the Reqistry which shows all the protocols, connections and skills which are available to you to construct your agents out of. To create a new agent and run it, follow these steps: In the [Create Agent id] box on the left. type the name of your agent - e.g. my_new_agent. This should now be the currently selected agent - but you can click on its name in the list to make sure. Click the [Create Agent] button - the newly created agent should appear in the [Local Agents] table On the right hand side, find the Echo skill and click on it - this will select it Click on the [Add skill] button - which should actually now say \"Add echo skill to my_new_agent agent\" Start an OEF Node, by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. This shows that the node has started successfully Start the agent running, by clicking on the [start agent] button - you should see the output from the echo agent appearing on the screen This is how your whole page should look if you followed the instructions correctly","title":"GUI"},{"location":"cli-gui/#preliminaries","text":"Ensure you have the framework installed and the CLI is working by following the quick-start guide .","title":"Preliminaries"},{"location":"cli-gui/#starting-the-gui","text":"Go to your working folder, where you want to create new agents. If you followed the quick start guide, this will be in the my_aea directory. Start the local web-server: aea gui Open this page in a browser: http://127.0.0.1:8080 You should see the following page displayed: On the left-hand side we can see any agents you have created and any protocols, connections and skills they have. Initially this will be empty - or if you have created an agent using the CLI in the quick-start guide and not deleted it then that should be listed. On the right-hand side is the Reqistry which shows all the protocols, connections and skills which are available to you to construct your agents out of. To create a new agent and run it, follow these steps: In the [Create Agent id] box on the left. type the name of your agent - e.g. my_new_agent. This should now be the currently selected agent - but you can click on its name in the list to make sure. Click the [Create Agent] button - the newly created agent should appear in the [Local Agents] table On the right hand side, find the Echo skill and click on it - this will select it Click on the [Add skill] button - which should actually now say \"Add echo skill to my_new_agent agent\" Start an OEF Node, by clicking on the [Start OEF Node] button. Wait for the text saying \"A thing of beauty is a joy forever...\" to appear. This shows that the node has started successfully Start the agent running, by clicking on the [start agent] button - you should see the output from the echo agent appearing on the screen This is how your whole page should look if you followed the instructions correctly","title":"Starting the GUI"},{"location":"cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"CLI tool"},{"location":"cli-how-to/#installation","text":"The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"Installation"},{"location":"connection/","text":"A Connection is attached to a MailBox within the AEA framework. The connection.py module in the connections directory contains two classes. A Connection object has a reference to a Channel . Channel : a wrapper for an SDK or API. Connection : a proxy to the functionality of an SDK or API. Configuration The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.AI Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of both Connection and Channel classes dependent on the protocol type. Channel send(self, envelope: Envelope) connect(self) -> Optional[Queue] disconnect(self) Connection is_established(self) connect(self) disconnect(self) send(self, envelope: Envelope) from_config(cls, public_key: str, connection_configuration: ConnectionConfig) Launching oef connections oef - local node Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection. oef - remote node Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"Connection"},{"location":"connection/#configuration","text":"The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.AI Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of both Connection and Channel classes dependent on the protocol type.","title":"Configuration"},{"location":"connection/#channel","text":"","title":"Channel"},{"location":"connection/#sendself-envelope-envelope","text":"","title":"send(self, envelope: Envelope)"},{"location":"connection/#connectself-gt-optionalqueue","text":"","title":"connect(self) -&gt; Optional[Queue]"},{"location":"connection/#disconnectself","text":"","title":"disconnect(self)"},{"location":"connection/#connection","text":"","title":"Connection"},{"location":"connection/#is_establishedself","text":"","title":"is_established(self)"},{"location":"connection/#connectself","text":"","title":"connect(self)"},{"location":"connection/#disconnectself_1","text":"","title":"disconnect(self)"},{"location":"connection/#sendself-envelope-envelope_1","text":"","title":"send(self, envelope: Envelope)"},{"location":"connection/#from_configcls-public_key-str-connection_configuration-connectionconfig","text":"","title":"from_config(cls, public_key: str, connection_configuration: ConnectionConfig)"},{"location":"connection/#launching-oef-connections","text":"","title":"Launching oef connections"},{"location":"connection/#oef-local-node","text":"Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection.","title":"oef - local node"},{"location":"connection/#oef-remote-node","text":"Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"oef - remote node"},{"location":"core-components/","text":"MailBox A MailBox contains InBox and OutBox queues containing Envelopes . Envelope An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Protocol Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept . Connection Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains two abstract classes which define a Channel and a Connection . A Connection contains one Channel , which acts as a bridge to the SDK or API to be wrapped. The Channel is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK. Skill Skills are a result of the framework's extensibility. They are atomic capabilities that agents can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the agent, and suggest action(s) to the agent according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the agent the best course of actions to take. For instance, an agent who is playing chess, could subscribe to more than one skill, where each skill corresponds to a specific strategy for playing chess. The skills could then read the internal state of the agent, including the agent's observation of the game's state, and suggest a next move to the agent. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement agents' reactive behaviour. If the agent understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement agents' proactiveness. Task : none, one or more Tasks encapsulate background work internal to the agent. Agent Main loop The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them. Decision maker The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the agent's crypto-economic security and goal management, and it contains the preference and ownership representation of the agent. Filter Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-register and re-register themselves. Resource The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Core components"},{"location":"core-components/#mailbox","text":"A MailBox contains InBox and OutBox queues containing Envelopes .","title":"MailBox"},{"location":"core-components/#envelope","text":"An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form.","title":"Envelope"},{"location":"core-components/#protocol","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions necessary for communication between AEAs via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept .","title":"Protocol"},{"location":"core-components/#connection","text":"Connections wrap an external SDK or API and manage messaging. As such, they allow the agent to connect to an external service with an exposed Python SDK/API. The module connections/base.py contains two abstract classes which define a Channel and a Connection . A Connection contains one Channel , which acts as a bridge to the SDK or API to be wrapped. The Channel is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK.","title":"Connection"},{"location":"core-components/#skill","text":"Skills are a result of the framework's extensibility. They are atomic capabilities that agents can dynamically take on board, in order to expand their effectiveness in different situations. A skill can be given permission to read the internal state of the the agent, and suggest action(s) to the agent according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the agent the best course of actions to take. For instance, an agent who is playing chess, could subscribe to more than one skill, where each skill corresponds to a specific strategy for playing chess. The skills could then read the internal state of the agent, including the agent's observation of the game's state, and suggest a next move to the agent. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task : Handler : each skill has none, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement agents' reactive behaviour. If the agent understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement agents' proactiveness. Task : none, one or more Tasks encapsulate background work internal to the agent.","title":"Skill"},{"location":"core-components/#agent","text":"","title":"Agent"},{"location":"core-components/#main-loop","text":"The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them.","title":"Main loop"},{"location":"core-components/#decision-maker","text":"The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for the agent's crypto-economic security and goal management, and it contains the preference and ownership representation of the agent.","title":"Decision maker"},{"location":"core-components/#filter","text":"Filter routes messages to the correct Handler via Resource . It also holds a reference to the currently active Behaviour and Task instances. By default for every skill, each Handler , Behaviour and Task is registered in the Filter . However, note that skills can de-register and re-register themselves.","title":"Filter"},{"location":"core-components/#resource","text":"The Resource component is made up of Registries for each type of resource (e.g. Protocol , Handler , Behaviour , Task ). Message Envelopes travel through the Filter which in turn fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Resource"},{"location":"design-principles/","text":"We have collated 8 principles which guide AEA framework development: Accessibility : easy of use. Modularity : encourages module creation and sharing and reuse. Openness : easily extensible with third party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"diagram/","text":"Note Work in progress. The framework can be divided into two parts: a) a core part that is developed by the Fetch.AI team as well as external contributors, and b) extensions (also known as packages ) developed by any developer. This allows for a modular and scalable framework. Currently, the framework supports three types of packages which can be added to the core part as modules: Skills Protocols Connections The following figure illustrates the framework's architecture:","title":"Architectural diagram"},{"location":"file-structure/","text":"The file structure of an agent is fixed. The top level directory has the agent's name. Below is a yaml configuration file, then directories containing the connections, protocols, and skills, and a file containing the private key of the agent. The developer can create new directories where necessary but the core structure must remain the same. The CLI tool provides a way to scaffold out the required directory structure for new agents. See the instructions for that here . agent_name/ aea-config.yaml YAML configuration of the agent private_key.pem The private key file connections/ Directory containing all the supported connections connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all supported protocols protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skill components skill_1/ First skill ... ... skill_k/ kth skill","title":"File structure"},{"location":"fipa-skill/","text":"Note Work in progress. The AEA FIPA skill demonstrates how FIPA negotiation strategies may be embedded into an Autonomous Economic Agent. Configuration The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled. Shared classes The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill. Search This class abstracts the logic required by agents performing searches for other buying/selling agents according to strategy (see below). Strategy This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether the agent intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not. Dialogue Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between. Transactions This class deals with representing potential transactions between agents. Demo instructions Warn Fipa negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the fipa agent. aea create my_fipa_agent Add the fipa skill cd my_fipa_agent aea add skill fipa_negotiation Add the local connection aea add connection local Run the agent with the default connection aea run --connection local Delete the agent When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"FIPA skill"},{"location":"fipa-skill/#configuration","text":"The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] Above, you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements register and search behaviour of an AEA for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled.","title":"Configuration"},{"location":"fipa-skill/#shared-classes","text":"The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill.","title":"Shared classes"},{"location":"fipa-skill/#search","text":"This class abstracts the logic required by agents performing searches for other buying/selling agents according to strategy (see below).","title":"Search"},{"location":"fipa-skill/#strategy","text":"This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether the agent intends to buy/sell something, and is therefore looking for other sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not.","title":"Strategy"},{"location":"fipa-skill/#dialogue","text":"Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between.","title":"Dialogue"},{"location":"fipa-skill/#transactions","text":"This class deals with representing potential transactions between agents.","title":"Transactions"},{"location":"fipa-skill/#demo-instructions","text":"Warn Fipa negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"fipa-skill/#create-the-agent","text":"In the root directory, create the fipa agent. aea create my_fipa_agent","title":"Create the agent"},{"location":"fipa-skill/#add-the-fipa-skill","text":"cd my_fipa_agent aea add skill fipa_negotiation","title":"Add the fipa skill"},{"location":"fipa-skill/#add-the-local-connection","text":"aea add connection local","title":"Add the local connection"},{"location":"fipa-skill/#run-the-agent-with-the-default-connection","text":"aea run --connection local","title":"Run the agent with the default connection"},{"location":"fipa-skill/#delete-the-agent","text":"When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"Delete the agent"},{"location":"gym-plugin/","text":"The gym_ex example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning. There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate environments, potentially owned by different entities. Quick start Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Packages Install the following packages. pip install numpy gym Files If you haven't done so already, download the examples and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym demo"},{"location":"gym-plugin/#quick-start","text":"","title":"Quick start"},{"location":"gym-plugin/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"gym-plugin/#packages","text":"Install the following packages. pip install numpy gym","title":"Packages"},{"location":"gym-plugin/#files","text":"If you haven't done so already, download the examples and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Files"},{"location":"gym-plugin/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses openai's gym library, may be embedded into an Autonomous Economic Agent. Demo instructions Follow the Preliminaries and Installation instructions here . Install the gym library. pip install gym Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the gym agent. aea create my_gym_agent Add the gym skill cd my_gym_agent aea add skill gym Copy the gym environment to the agent directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Add a gym connection aea add connection gym Update the connection config nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom Run the agent with the gym connection aea run --connection gym You will see the gym training logs. Delete the agent When you're done, you can go up a level and delete the agent. aea delete my_gym_agent","title":"Gym skill"},{"location":"gym-skill/#demo-instructions","text":"Follow the Preliminaries and Installation instructions here . Install the gym library. pip install gym Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"gym-skill/#create-the-agent","text":"In the root directory, create the gym agent. aea create my_gym_agent","title":"Create the agent"},{"location":"gym-skill/#add-the-gym-skill","text":"cd my_gym_agent aea add skill gym","title":"Add the gym skill"},{"location":"gym-skill/#copy-the-gym-environment-to-the-agent-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the agent directory"},{"location":"gym-skill/#add-a-gym-connection","text":"aea add connection gym","title":"Add a gym connection"},{"location":"gym-skill/#update-the-connection-config","text":"nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom","title":"Update the connection config"},{"location":"gym-skill/#run-the-agent-with-the-gym-connection","text":"aea run --connection gym You will see the gym training logs.","title":"Run the agent with the gym connection"},{"location":"gym-skill/#delete-the-agent","text":"When you're done, you can go up a level and delete the agent. aea delete my_gym_agent","title":"Delete the agent"},{"location":"integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.AI and third party ledgers. Fetch.AI Ledger Note Coming soon. Ethereum Ledger Note Coming soon.","title":"Integrate with third parties"},{"location":"integration/#fetchai-ledger","text":"Note Coming soon.","title":"Fetch.AI Ledger"},{"location":"integration/#ethereum-ledger","text":"Note Coming soon.","title":"Ethereum Ledger"},{"location":"logging/","text":"Logging The framework supports flexible logging capabilities by relying on the standard Python logging library . In this tutorial, you'll see how you can configure logging for your agent. First of all, create your agent: aea create my_agent cd my_agent The aea-config.yaml file should look like: aea_version : 0.1.6 agent_name : my_agent authors : '' connections : - oef default_connection : oef license : '' private_key_pem_path : '' protocols : - default registry_path : ../packages skills : - error url : '' version : v1 logging_config : disable_existing_loggers : false version : 1 By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. An example of logging_config value is reported below: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : true This configuration wiill set up a logger with name aea , print both on console (see console handler) and on file (see logfile handler) with format specified by the standard formatter.","title":"Logging"},{"location":"logging/#logging","text":"The framework supports flexible logging capabilities by relying on the standard Python logging library . In this tutorial, you'll see how you can configure logging for your agent. First of all, create your agent: aea create my_agent cd my_agent The aea-config.yaml file should look like: aea_version : 0.1.6 agent_name : my_agent authors : '' connections : - oef default_connection : oef license : '' private_key_pem_path : '' protocols : - default registry_path : ../packages skills : - error url : '' version : v1 logging_config : disable_existing_loggers : false version : 1 By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. An example of logging_config value is reported below: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : true This configuration wiill set up a logger with name aea , print both on console (see console handler) and on file (see logfile handler) with format specified by the standard formatter.","title":"Logging"},{"location":"protocol/","text":"A Protocol manages message representation, encoding, and serialisation. It also defines the rules to which messages must adhere. An agent can have one or more protocols. The AEA framework supplies three: oef , fipa , and a default protocol. Custom protocol For a custom protocol, the developer must code methods from two classes. Message.check_consistency(self) This method checks the message data for consistency and raises an error if necessary. Todo For example. Serializer.encode(self, msg: Message) This method encodes a message object into bytes for passing around. Todo For example. Serializer.decode(self, obj: bytes) This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way they see fit. rules.py Note Coming soon. oef protocol The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc. fipa protocol The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Peformative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } } default protocol The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"Protocol"},{"location":"protocol/#custom-protocol","text":"For a custom protocol, the developer must code methods from two classes.","title":"Custom protocol"},{"location":"protocol/#messagecheck_consistencyself","text":"This method checks the message data for consistency and raises an error if necessary. Todo For example.","title":"Message.check_consistency(self)"},{"location":"protocol/#serializerencodeself-msg-message","text":"This method encodes a message object into bytes for passing around. Todo For example.","title":"Serializer.encode(self, msg: Message)"},{"location":"protocol/#serializerdecodeself-obj-bytes","text":"This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way they see fit.","title":"Serializer.decode(self, obj: bytes)"},{"location":"protocol/#rulespy","text":"Note Coming soon.","title":"rules.py"},{"location":"protocol/#oef-protocol","text":"The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc.","title":"oef protocol"},{"location":"protocol/#fipa-protocol","text":"The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Peformative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } }","title":"fipa protocol"},{"location":"protocol/#default-protocol","text":"The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"default protocol"},{"location":"quickstart/","text":"Preliminaries Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell Installation Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA, including the CLI (Command Line Interface) extension, alone. pip install aea [ cli ] Echo skill demo The echo skill is a simple demo that prints logs from the agent's main loop as it calls registered Task and Behaviour code. Download the scripts and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create a new agent aea create my_first_agent Add the echo skill cd my_first_agent aea add skill echo Add a local connection aea add connection local A local connection provides a local stub for an OEF node instance. Run the agent Run the agent with the local connection. aea run --connection local You will see the echo task running in the terminal window. Stop the agent Stop the agent by pressing CTRL c Delete the agent When you're done, you can delete the agent (first go to the parent directory via cd .. ). aea delete my_first_agent","title":"AEA quick start"},{"location":"quickstart/#preliminaries","text":"Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell","title":"Preliminaries"},{"location":"quickstart/#installation","text":"Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA, including the CLI (Command Line Interface) extension, alone. pip install aea [ cli ]","title":"Installation"},{"location":"quickstart/#echo-skill-demo","text":"The echo skill is a simple demo that prints logs from the agent's main loop as it calls registered Task and Behaviour code.","title":"Echo skill demo"},{"location":"quickstart/#download-the-scripts-and-packages-directories","text":"svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Download the scripts and packages directories."},{"location":"quickstart/#create-a-new-agent","text":"aea create my_first_agent","title":"Create a new agent"},{"location":"quickstart/#add-the-echo-skill","text":"cd my_first_agent aea add skill echo","title":"Add the echo skill"},{"location":"quickstart/#add-a-local-connection","text":"aea add connection local A local connection provides a local stub for an OEF node instance.","title":"Add a local connection"},{"location":"quickstart/#run-the-agent","text":"Run the agent with the local connection. aea run --connection local You will see the echo task running in the terminal window.","title":"Run the agent"},{"location":"quickstart/#stop-the-agent","text":"Stop the agent by pressing CTRL c","title":"Stop the agent"},{"location":"quickstart/#delete-the-agent","text":"When you're done, you can delete the agent (first go to the parent directory via cd .. ). aea delete my_first_agent","title":"Delete the agent"},{"location":"scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml . Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a connection aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffolding"},{"location":"scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml .","title":"Scaffold generator"},{"location":"scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffold a connection"},{"location":"skill-guide/","text":"The scaffolding tool allows you create the folder structure required for a skill. Note Before developing your first skill, please read the skill guide . Step 1: Setup Ensure, you have followed the preliminaries and installation . We will first create an agent and add a scaffold skill, which we call my_search : aea create my_agent && cd my_agent aea scaffold skill my_search In the following steps, we will replace each one of the scaffolded Behaviour , Handler and Task in my_agent/skills/my_search with our implementation. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF. import logging import time from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.models import Query , Constraint , ConstraintType from aea.protocols.oef.serialization import DEFAULT_OEF , OEFSerializer from aea.skills.base import Behaviour logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchBehaviour ( Behaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchBehaviour\" . format ( self . context . agent_name )) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" time . sleep ( 1 ) # to slow down the agent self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OEFMessage ( oef_type = OEFMessage . Type . SEARCH_SERVICES , id = self . sent_search_count , query = search_query_w_empty_model ) logger . info ( \"[{}]: sending search request to OEF, search_count={}\" . format ( self . context . agent_name , self . sent_search_count )) self . context . outbox . put_message ( to = DEFAULT_OEF , sender = self . context . agent_address , protocol_id = OEFMessage . protocol_id , message = OEFSerializer () . encode ( search_request )) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchBehaviour\" . format ( self . context . agent_name )) Searches are proactive and as such well placed in a Behaviour . We place this code in my_agent/skills/my_search/behaviours.py . Step 3: Develop a Handler So far, we have tasked the agent with sending search requests to the OEF. However, we have no way of handling the responses sent to the agent by the OEF at the moment. The agent would simply respond to the OEF via the default error skill which sends all unrecognized envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. import logging from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.serialization import OEFSerializer from aea.skills.base import Handler logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OEFMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" logger . info ( \"[{}]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OEFMessage , sender : str ) -> None : \"\"\" Handle the message. :param message: the message. :param sender: the sender. :return: None \"\"\" msg_type = OEFMessage . Type ( message . get ( \"type\" )) if msg_type is OEFMessage . Type . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) logger . info ( \"[{}]: found number of agents={}, received search count={}\" . format ( self . context . agent_name , nb_agents_found , self . received_search_count )) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchHandler\" . format ( self . context . agent_name )) We create a handler which is registered for the oef protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. We place this code in my_agent/skills/my_search/handlers.py . Step 4: Develop a Task We have implemented a behaviour and a handler. We conclude by implementing a task. Here we can implement background logic. We will implement a trivial check on the difference between the amount of search requests sent and responses received. import logging from aea.skills.base import Task logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchTask ( Task ): \"\"\"This class scaffolds a task.\"\"\" def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchTask\" . format ( self . context . agent_name )) def execute ( self ) -> None : \"\"\" Implement the task execution. :param envelope: the envelope :return: None \"\"\" my_search_behaviour = self . context . behaviours [ 0 ] my_search_handler = self . context . handlers [ 0 ] logger . info ( \"[{}]: number of search requests sent={} vs. number of search responses received={}\" . format ( self . context . agent_name , my_search_behaviour . sent_search_count , my_search_handler . received_search_count ) ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchTask\" . format ( self . context . agent_name )) Note, how we have access to other objects in the skill via self.context . We place this code in my_agent/skills/my_search/tasks.py . Step 5: Create the config file Based on our skill components above, we create the following config file: name : my_search authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" description : 'A simple search skill utilising the OEF.' behaviours : - behaviour : class_name : MySearchBehaviour args : {} handlers : - handler : class_name : MySearchHandler args : {} tasks : - task : class_name : MySearchTask args : {} shared_classes : [] protocols : [ \"oef\" ] dependencies : [] We place this code in my_agent/skills/my_search/skill.yaml . Step 6: Add the oef protocol Our agent does not have the oef protocol yet. Hence, we add it like so: aea add protocol oef Step 7: Run the agent We first start an oef node (see the connection section for more details) in a separate terminal window: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json We can then launch our agent: aea run Stop the agent with CTRL + C . Now it's your turn: We hope this step by step introduction has helped you to develop your own skill. We are excited to see what you will build.","title":"Build your own skill"},{"location":"skill-guide/#step-1-setup","text":"Ensure, you have followed the preliminaries and installation . We will first create an agent and add a scaffold skill, which we call my_search : aea create my_agent && cd my_agent aea scaffold skill my_search In the following steps, we will replace each one of the scaffolded Behaviour , Handler and Task in my_agent/skills/my_search with our implementation.","title":"Step 1: Setup"},{"location":"skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the OEF. import logging import time from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.models import Query , Constraint , ConstraintType from aea.protocols.oef.serialization import DEFAULT_OEF , OEFSerializer from aea.skills.base import Behaviour logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchBehaviour ( Behaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchBehaviour\" . format ( self . context . agent_name )) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" time . sleep ( 1 ) # to slow down the agent self . sent_search_count += 1 search_constraints = [ Constraint ( \"country\" , ConstraintType ( \"==\" , \"UK\" ))] search_query_w_empty_model = Query ( search_constraints , model = None ) search_request = OEFMessage ( oef_type = OEFMessage . Type . SEARCH_SERVICES , id = self . sent_search_count , query = search_query_w_empty_model ) logger . info ( \"[{}]: sending search request to OEF, search_count={}\" . format ( self . context . agent_name , self . sent_search_count )) self . context . outbox . put_message ( to = DEFAULT_OEF , sender = self . context . agent_address , protocol_id = OEFMessage . protocol_id , message = OEFSerializer () . encode ( search_request )) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchBehaviour\" . format ( self . context . agent_name )) Searches are proactive and as such well placed in a Behaviour . We place this code in my_agent/skills/my_search/behaviours.py .","title":"Step 2: Develop a Behaviour"},{"location":"skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the agent with sending search requests to the OEF. However, we have no way of handling the responses sent to the agent by the OEF at the moment. The agent would simply respond to the OEF via the default error skill which sends all unrecognized envelopes back to the sender. Let us now implement a handler to deal with the incoming search responses. import logging from aea.protocols.oef.message import OEFMessage from aea.protocols.oef.serialization import OEFSerializer from aea.skills.base import Handler logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OEFMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" logger . info ( \"[{}]: setting up MySearchHandler\" . format ( self . context . agent_name )) def handle ( self , message : OEFMessage , sender : str ) -> None : \"\"\" Handle the message. :param message: the message. :param sender: the sender. :return: None \"\"\" msg_type = OEFMessage . Type ( message . get ( \"type\" )) if msg_type is OEFMessage . Type . SEARCH_RESULT : self . received_search_count += 1 nb_agents_found = len ( message . get ( \"agents\" )) logger . info ( \"[{}]: found number of agents={}, received search count={}\" . format ( self . context . agent_name , nb_agents_found , self . received_search_count )) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchHandler\" . format ( self . context . agent_name )) We create a handler which is registered for the oef protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. We place this code in my_agent/skills/my_search/handlers.py .","title":"Step 3: Develop a Handler"},{"location":"skill-guide/#step-4-develop-a-task","text":"We have implemented a behaviour and a handler. We conclude by implementing a task. Here we can implement background logic. We will implement a trivial check on the difference between the amount of search requests sent and responses received. import logging from aea.skills.base import Task logger = logging . getLogger ( \"aea.my_search_skill\" ) class MySearchTask ( Task ): \"\"\"This class scaffolds a task.\"\"\" def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" logger . info ( \"[{}]: setting up MySearchTask\" . format ( self . context . agent_name )) def execute ( self ) -> None : \"\"\" Implement the task execution. :param envelope: the envelope :return: None \"\"\" my_search_behaviour = self . context . behaviours [ 0 ] my_search_handler = self . context . handlers [ 0 ] logger . info ( \"[{}]: number of search requests sent={} vs. number of search responses received={}\" . format ( self . context . agent_name , my_search_behaviour . sent_search_count , my_search_handler . received_search_count ) ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" logger . info ( \"[{}]: tearing down MySearchTask\" . format ( self . context . agent_name )) Note, how we have access to other objects in the skill via self.context . We place this code in my_agent/skills/my_search/tasks.py .","title":"Step 4: Develop a Task"},{"location":"skill-guide/#step-5-create-the-config-file","text":"Based on our skill components above, we create the following config file: name : my_search authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" description : 'A simple search skill utilising the OEF.' behaviours : - behaviour : class_name : MySearchBehaviour args : {} handlers : - handler : class_name : MySearchHandler args : {} tasks : - task : class_name : MySearchTask args : {} shared_classes : [] protocols : [ \"oef\" ] dependencies : [] We place this code in my_agent/skills/my_search/skill.yaml .","title":"Step 5: Create the config file"},{"location":"skill-guide/#step-6-add-the-oef-protocol","text":"Our agent does not have the oef protocol yet. Hence, we add it like so: aea add protocol oef","title":"Step 6: Add the oef protocol"},{"location":"skill-guide/#step-7-run-the-agent","text":"We first start an oef node (see the connection section for more details) in a separate terminal window: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json We can then launch our agent: aea run Stop the agent with CTRL + C .","title":"Step 7: Run the agent"},{"location":"skill-guide/#now-its-your-turn","text":"We hope this step by step introduction has helped you to develop your own skill. We are excited to see what you will build.","title":"Now it's your turn:"},{"location":"skill/","text":"An agent developer writes skills that the framework can call. When you add a skill with the CLI, a directory is created which includes modules for the Behaviour, Task , and Handler classes as well as a configuration file skill.yaml . Context The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the agent context. The agent context provides read access to agent specific information like the public key and address of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example. behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example. tasks.py Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example. Shared classes The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class Skill config Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ] Error skill All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the default protocol which provides error codes for the above.","title":"Skill"},{"location":"skill/#context","text":"The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context also has a link to the agent context. The agent context provides read access to agent specific information like the public key and address of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example.","title":"handlers.py"},{"location":"skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example.","title":"behaviours.py"},{"location":"skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example.","title":"tasks.py"},{"location":"skill/#shared-classes","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class","title":"Shared classes"},{"location":"skill/#skill-config","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ]","title":"Skill config"},{"location":"skill/#error-skill","text":"All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the default protocol which provides error codes for the above.","title":"Error skill"},{"location":"steps/","text":"There are a number of ways to build an agent. We recommended you build an AEA project with the CLI tool as mentioned in the quick start guide. See information on the CLI tool here . [Coming soon!] Using the CLI fetch command, pull in an already built project and run as normal. The last option is to install the AEA without the CLI tool with pip install aea and, from there, import classes directly. Set up your skills . Code the protocols . Add the connections . Scaffold any of the above resources with the scaffolding tool . This guide shows you step by step how to develop a skill. Now, build and run your agent using the quick start guide .","title":"Step by step"},{"location":"tac-skill/","text":"Todo","title":"TAC skill"},{"location":"tac/","text":"TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include submodules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Launcher GUI Todo Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"tac/#quick-start","text":"Clone the repo to include submodules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"tac/#launcher-gui","text":"Todo","title":"Launcher GUI"},{"location":"tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"version/","text":"The current version of the Autonomous Economic Agent framework is 0.1.x . The framework is under rapid development with frequent breaking changes.","title":"Version"},{"location":"weather-skills/","text":"The AEA wheather skills demonstrates a scenario where two AEA agents interact, one as the provider of weather data, the other as the seller of weather data. Demo instructions Follow the Preliminaries and Installation instructions here . Download the packages and scripts directories. svn export https://github.com/fetchai/agents-aea.git/trunk/packages svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Launch the OEF Node: In a separate terminal, launch an OEF node locally: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Create the weather station agent: In the root directory, create the weather station agent. aea create my_weather_station Add the weather station skill cd my_weather_station aea add skill weather_station Run the weather station agent aea run Create the weather client agent: Return to the root directory, and create the weather client agent. aea create my_weather_client Add the weather client skill cd my_weather_client aea add skill weather_client Run the weather client agent aea run Observe the logs of both agents: Delete the agents When you're done, you can go up a level and delete the agents. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Weather skills"},{"location":"weather-skills/#demo-instructions","text":"Follow the Preliminaries and Installation instructions here . Download the packages and scripts directories. svn export https://github.com/fetchai/agents-aea.git/trunk/packages svn export https://github.com/fetchai/agents-aea.git/trunk/scripts","title":"Demo instructions"},{"location":"weather-skills/#launch-the-oef-node","text":"In a separate terminal, launch an OEF node locally: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json","title":"Launch the OEF Node:"},{"location":"weather-skills/#create-the-weather-station-agent","text":"In the root directory, create the weather station agent. aea create my_weather_station","title":"Create the weather station agent:"},{"location":"weather-skills/#add-the-weather-station-skill","text":"cd my_weather_station aea add skill weather_station","title":"Add the weather station skill"},{"location":"weather-skills/#run-the-weather-station-agent","text":"aea run","title":"Run the weather station agent"},{"location":"weather-skills/#create-the-weather-client-agent","text":"Return to the root directory, and create the weather client agent. aea create my_weather_client","title":"Create the weather client agent:"},{"location":"weather-skills/#add-the-weather-client-skill","text":"cd my_weather_client aea add skill weather_client","title":"Add the weather client skill"},{"location":"weather-skills/#run-the-weather-client-agent","text":"aea run","title":"Run the weather client agent"},{"location":"weather-skills/#observe-the-logs-of-both-agents","text":"","title":"Observe the logs of both agents:"},{"location":"weather-skills/#delete-the-agents","text":"When you're done, you can go up a level and delete the agents. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the agents"}]}