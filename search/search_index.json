{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The AEA framework is a Python ecosystem for autonomous economic agent (AEA) development. It equips developers with a simple to understand and efficient set of tools for building autonomous economic agents. The framework is super modular, easily extensible, and highly composable. It is ideal for reinforcement learning scenarios. The AEA framework attempts to make agent development as straightforward as many popular web frameworks. Our vision The AEA framework has two focused commercial roles. Open source technology We are creating infrastructure for agent developers to use to build their own solutions. AEA users are, among others: Data scientists. Machine learning experts. Engineers. Economists. Web developers. Students/Academics. AI/ML/MAS Researchers. Crypto passionates. Indie developers. Platform for start ups By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base. Agents An autonomous economic agent (AEA) is an intelligent agent whose goal is generating economic value for its owner. The AEA super power is the ability to autonomously acquire new skills. AEAs achieve their goals with the help of the Fetch.AI OEF and the Fetch.AI Ledger. Third party systems, such as Ethereum, may also allow AEA integration. Note This developer documentation is work in progress. IF you spot any errors please open an issue here .","title":"What is the AEA framework?"},{"location":"#our-vision","text":"The AEA framework has two focused commercial roles.","title":"Our vision"},{"location":"#open-source-technology","text":"We are creating infrastructure for agent developers to use to build their own solutions. AEA users are, among others: Data scientists. Machine learning experts. Engineers. Economists. Web developers. Students/Academics. AI/ML/MAS Researchers. Crypto passionates. Indie developers.","title":"Open source technology"},{"location":"#platform-for-start-ups","text":"By operating as a platform for start ups, we envisage the AEA framework to be in a continuous growth pattern. With start up grants we will kick start solutions while testing product-problem fit and identifying our user base.","title":"Platform for start ups"},{"location":"#agents","text":"An autonomous economic agent (AEA) is an intelligent agent whose goal is generating economic value for its owner. The AEA super power is the ability to autonomously acquire new skills. AEAs achieve their goals with the help of the Fetch.AI OEF and the Fetch.AI Ledger. Third party systems, such as Ethereum, may also allow AEA integration. Note This developer documentation is work in progress. IF you spot any errors please open an issue here .","title":"Agents"},{"location":"cli-commands/","text":"CLI commands Command Description create [name] Create a new aea project. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill. add connection/protocol/skill [name] Add connection, protocol, or skill to agent. remove connection/protocol/skill [name] Remove connection, protocol, or skill from agent. run {using [connection, ...]} Run the agent on the Fetch.AI network with default or specified connections. -v DEBUG run Run with debugging. delete [name] Delete an aea project. See below for disabling a resource. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"Commands"},{"location":"cli-commands/#cli-commands","text":"Command Description create [name] Create a new aea project. scaffold connection/protocol/skill [name] Scaffold a new connection, protocol, or skill. add connection/protocol/skill [name] Add connection, protocol, or skill to agent. remove connection/protocol/skill [name] Remove connection, protocol, or skill from agent. run {using [connection, ...]} Run the agent on the Fetch.AI network with default or specified connections. -v DEBUG run Run with debugging. delete [name] Delete an aea project. See below for disabling a resource. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace.","title":"CLI commands"},{"location":"cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"CLI tool"},{"location":"cli-how-to/#installation","text":"The following installs the AEA cli package. pip install aea [ cli ] The following installs the entire AEA package including the cli. pip install aea [ all ]","title":"Installation"},{"location":"connection/","text":"A Connection is attached to a MailBox within the AEA framework. The connection.py module in the connections directory contains two classes. A Connection object has a reference to a Channel . Channel : a wrapper for an SDK or API. Connection : a proxy to the functionality of an SDK or API. Configuration The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.AI Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of both Connection and Channel classes dependent on the protocol type. Channel send(self, envelope: Envelope) connect(self) -> Optional[Queue] disconnect(self) Connection is_established(self) connect(self) disconnect(self) send(self, envelope: Envelope) from_config(cls, public_key: str, connection_configuration: ConnectionConfig) Launching oef connections oef - local node Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection. oef - remote node Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"Connection"},{"location":"connection/#configuration","text":"The connection.yaml file in the agent directory contains protocol details and connection url and port details. For example, the oef connection.yaml contains the connection class name, supported protocols, and any connection configuration details. name: oef authors: Fetch.AI Limited version: 0.1 . 0 license: Apache 2.0 url: \"\" class_name: OEFConnection supported_protocols: [ \"oef\" ] config: addr: 127.0 . 0.1 port: 10000 The developer is left to implement the methods of both Connection and Channel classes dependent on the protocol type.","title":"Configuration"},{"location":"connection/#channel","text":"","title":"Channel"},{"location":"connection/#sendself-envelope-envelope","text":"","title":"send(self, envelope: Envelope)"},{"location":"connection/#connectself-gt-optionalqueue","text":"","title":"connect(self) -&gt; Optional[Queue]"},{"location":"connection/#disconnectself","text":"","title":"disconnect(self)"},{"location":"connection/#connection","text":"","title":"Connection"},{"location":"connection/#is_establishedself","text":"","title":"is_established(self)"},{"location":"connection/#connectself","text":"","title":"connect(self)"},{"location":"connection/#disconnectself_1","text":"","title":"disconnect(self)"},{"location":"connection/#sendself-envelope-envelope_1","text":"","title":"send(self, envelope: Envelope)"},{"location":"connection/#from_configcls-public_key-str-connection_configuration-connectionconfig","text":"","title":"from_config(cls, public_key: str, connection_configuration: ConnectionConfig)"},{"location":"connection/#launching-oef-connections","text":"","title":"Launching oef connections"},{"location":"connection/#oef-local-node","text":"Download the scripts directory: svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Then, start an oef from a separate terminal: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json This pulls and runs an oef docker image. Now you can run an AEA with an oef connection.","title":"oef - local node"},{"location":"connection/#oef-remote-node","text":"Connect directly to a running oef via a given URL:PORT . Update the configuration of the oef connection in the connection.yaml file.","title":"oef - remote node"},{"location":"core-components/","text":"MailBox A MailBox contains InBox and OutBox queues containing Envelopes . Envelope An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form. Protocol Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions needed for AEA agent communication via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept . Connection Connections wrap an external SDK or API and manage the messaging. They allow the agent to connect to an external service which has a Python SDK or API. The module connections/base.py contains two abstract classes which define a Channel and a Connection . A Connection contains one Channel , which acts as a bridge to the SDK or API to be wrapped. The Channel is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK. Skill Skills deliver economic value to the AEA by allowing agents to encapsulate and call any kind of code. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task . Handler : each skill has none, one or more Handler objects responsible for the registered protocol messaging. Handlers implement reactive behaviour. By understanding the requirements contained in an Envelope , the Handler reacts appropriately to message requests. Each Handler is responsible for one and only one protocol. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement proactive behaviour. Task : none, one or more Tasks encapsulate background work internal to the agent. Agent Main loop The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them. Decision maker The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for crypto-economic security and goal management and contains the preference and ownership representation of the agent. Filter The Filter routes messages to the correct Handler via the Resource component. It also holds a reference to the currently active Behaviour and Task instances. By default each Handler , Behaviour and Task of each skill is registered in the Filter . However, skills can de-register and re-register themselves. Resource The Resource component is made up of Registries which contain Resources ( Protocol , Handler , Behaviour , Task ). There is one Registry for each type of Resource. Message Envelopes travel through the Filter which fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Core components"},{"location":"core-components/#mailbox","text":"A MailBox contains InBox and OutBox queues containing Envelopes .","title":"MailBox"},{"location":"core-components/#envelope","text":"An Envelope is the core object with which agents communicate. It travels from OutBox to another agent. Envelope objects sent from other agents arrive in the InBox via a connection. An Envelope is a vehicle for messages with four attribute parameters: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the protocol. message : is a bytes field which holds the message in serialized form.","title":"Envelope"},{"location":"core-components/#protocol","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol may contain messages of type START and FINISH . From there, the rules may prescribe that a message of type FINISH must be preceded by a message of type START . The Message class in the protocols/base.py module provides an abstract class with all the functionality a derived Protocol message class requires for a custom protocol, such as basic message generating and management functions and serialisation details. A number of protocols come packaged up with the AEA framework. default : this protocol provides a bare bones implementation for an AEA protocol which includes a DefaultMessage class and a DefaultSerialization class with functions for managing serialisation. Use this protocol as a starting point for building custom protocols. oef : this protocol provides the AEA protocol implementation for communication with the OEF including an OEFMessage class for hooking up to OEF services and search agents. Utility classes are available in the models.py module which provides OEF specific requirements such as classes needed to perform querying on the OEF such as Description , Query , and Constraint , to name a few. fipa : this protocol provides classes and functions needed for AEA agent communication via the FIPA Agent Communication Language. For example, the FIPAMessage class provides negotiation terms such as cfp , propose , decline , accept and match_accept .","title":"Protocol"},{"location":"core-components/#connection","text":"Connections wrap an external SDK or API and manage the messaging. They allow the agent to connect to an external service which has a Python SDK or API. The module connections/base.py contains two abstract classes which define a Channel and a Connection . A Connection contains one Channel , which acts as a bridge to the SDK or API to be wrapped. The Channel is responsible for translating between the framework specific Envelope with its contained Message and the external service. The framework provides a number of default connections. local : implements a local node. oef : wraps the OEF SDK.","title":"Connection"},{"location":"core-components/#skill","text":"Skills deliver economic value to the AEA by allowing agents to encapsulate and call any kind of code. A skill encapsulates implementations of the abstract base classes Handler , Behaviour , and Task . Handler : each skill has none, one or more Handler objects responsible for the registered protocol messaging. Handlers implement reactive behaviour. By understanding the requirements contained in an Envelope , the Handler reacts appropriately to message requests. Each Handler is responsible for one and only one protocol. Behaviour : none, one or more Behaviours encapsulate actions that cause interactions with other agents initiated by the agent. Behaviours implement proactive behaviour. Task : none, one or more Tasks encapsulate background work internal to the agent.","title":"Skill"},{"location":"core-components/#agent","text":"","title":"Agent"},{"location":"core-components/#main-loop","text":"The _run_main_loop() function in the Agent class performs a series of activities while the Agent state is not stopped. act() : this function calls the act() function of all registered Behaviours. react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the protocol of the Envelope . update() : this function loops through all the Tasks and executes them.","title":"Main loop"},{"location":"core-components/#decision-maker","text":"The DecisionMaker component manages global agent state updates proposed by the skills and processes the resulting ledger transactions. It is responsible for crypto-economic security and goal management and contains the preference and ownership representation of the agent.","title":"Decision maker"},{"location":"core-components/#filter","text":"The Filter routes messages to the correct Handler via the Resource component. It also holds a reference to the currently active Behaviour and Task instances. By default each Handler , Behaviour and Task of each skill is registered in the Filter . However, skills can de-register and re-register themselves.","title":"Filter"},{"location":"core-components/#resource","text":"The Resource component is made up of Registries which contain Resources ( Protocol , Handler , Behaviour , Task ). There is one Registry for each type of Resource. Message Envelopes travel through the Filter which fetches the correct Handler from the Registry . Specific Registry classes are in the registries/base.py module. ProtocolRegistry . HandlerRegistry . BehaviourRegistry . TaskRegistry .","title":"Resource"},{"location":"design-principles/","text":"We have collated 8 principles which guide AEA framework development: Accessibility: easy to use. Modularity: encourages module creation and sharing. Openness: easily extensible with third party libraries. Conciseness: conceptually simple. Value-driven: drives immediate value for some use case. Low entry barriers: leverages existing programming languages and web protocols. Safety: safe for the user (economically speaking). Goal alignment: seamless facilitation of user preferences and goals.","title":"Design principles"},{"location":"diagram/","text":"Note Work in progress. The framework can be divided into two parts. The core framework which constitutes the AEA framework developed by the Fetch.AI team and external contributers ad well as extensions (packages) which can be developed by any developer. This allows for a modular and scalable agent framework. There exist currently three types of packages which can be added to the framework as modules: Skills Protocols Connections We first provide a graphical illustration of the framework and then discuss its components:","title":"Architectural diagram"},{"location":"file-structure/","text":"The file structure of an agent is fixed. The top level directory has the agent's name. Below is a yaml configuration file, then directories containing the connections, protocols, and skills, and a file containing the private key of the agent. The developer can create new directories where necessary but the core structure must remain the same. The CLI tool provides a way to scaffold out the required directory structure for new agents. See the instructions for that here . agent_name/ aea-config.yaml YAML configuration of the agent priv.pem The private key file connections/ Directory containing all the supported connections connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all supported protocols protocol_1/ First protocol ... ... protocol_k/ kth protocol skills/ Directory containing all the skill components skill_1/ First skill ... ... skill_n/ nth skill","title":"File structure"},{"location":"fipa-skill/","text":"Note Work in progress. The AEA FIPA skill demonstrates how FIPA negotiation strategies may be embedded into an Autonomous Economic Agent. Configuration The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] In it you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements the AEA agent register and search behaviour for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled. Shared classes The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill. Search This class abstracts the logic required by agents performing searches for other buyer or seller agents depending on strategy. Strategy This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether it is a buyer looking for sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not. Dialogue Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between. Transactions This class deals with representing potential transactions between agents. Demo instructions Warn Fipa negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the fipa agent. aea create my_fipa_agent Add the fipa skill cd my_fipa_agent aea add skill fipa_negotiation Add the local connection aea add connection local Run the agent with the default connection aea run --connection local Delete the agent When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"FIPA skill"},{"location":"fipa-skill/#configuration","text":"The FIPA skill skill.yaml configuration file looks like this. name : 'fipa_negotiation' authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : GoodsRegisterAndSearchBehaviour args : services_interval : 5 handlers : - handler : class_name : FIPANegotiationHandler args : {} tasks : - task : class_name : TransactionCleanUpTask args : {} shared_classes : - shared_class : class_name : Search args : {} - shared_class : class_name : Strategy args : {} - shared_class : class_name : Dialogues args : {} - shared_class : class_name : Transactions args : pending_transaction_timeout : 30 protocols : [ 'oef' , 'fipa' ] In it you can see the registered Behaviour class name GoodsRegisterAndSearchBehaviour which implements the AEA agent register and search behaviour for the FIPA skill. The FIPANegotiationHandler deals with receiving FIPAMessage types containing FIPA negotiation terms, such as cfp , propose , decline , accept and match_accept . The TransactionCleanUpTask takes care of removing potential transaction of different degrees of commitment from the potential transactions list if they are unlikely to be settled.","title":"Configuration"},{"location":"fipa-skill/#shared-classes","text":"The shared_classes element in the configuration yaml lists a number of important classes for agents communicating via the FIPA skill.","title":"Shared classes"},{"location":"fipa-skill/#search","text":"This class abstracts the logic required by agents performing searches for other buyer or seller agents depending on strategy.","title":"Search"},{"location":"fipa-skill/#strategy","text":"This class defines the strategy behind an agent's activities. The class is instantiated with the agent's goals, for example whether it is a buyer looking for sellers, buyers, or both. It also provides methods for defining what goods agents are looking for and what goods they may have to sell, for generating proposal queries, and checking whether a proposal is profitable or not.","title":"Strategy"},{"location":"fipa-skill/#dialogue","text":"Dialogues abstract the negotiations that take place between agents including all negotiation end states, such as accepted, declined, etc. and all the negotiation states in between.","title":"Dialogue"},{"location":"fipa-skill/#transactions","text":"This class deals with representing potential transactions between agents.","title":"Transactions"},{"location":"fipa-skill/#demo-instructions","text":"Warn Fipa negotiation skill is not fully developed. Follow the Preliminaries and Installation instructions here . Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"fipa-skill/#create-the-agent","text":"In the root directory, create the fipa agent. aea create my_fipa_agent","title":"Create the agent"},{"location":"fipa-skill/#add-the-fipa-skill","text":"cd my_fipa_agent aea add skill fipa_negotiation","title":"Add the fipa skill"},{"location":"fipa-skill/#add-the-local-connection","text":"aea add connection local","title":"Add the local connection"},{"location":"fipa-skill/#run-the-agent-with-the-default-connection","text":"aea run --connection local","title":"Run the agent with the default connection"},{"location":"fipa-skill/#delete-the-agent","text":"When you're done, go up a level and delete the agent. cd .. aea delete my_fipa_agent","title":"Delete the agent"},{"location":"gym-plugin/","text":"The gym_ex example demonstrates to Reinforcement Learning developers the AEA framework's flexibility. There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate environments, potentially owned by different entities. Quick start Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Packages Install the following packages. pip install numpy gym Files If you haven't done so already, download the examples and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym demo"},{"location":"gym-plugin/#quick-start","text":"","title":"Quick start"},{"location":"gym-plugin/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"gym-plugin/#packages","text":"Install the following packages. pip install numpy gym","title":"Packages"},{"location":"gym-plugin/#files","text":"If you haven't done so already, download the examples and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Files"},{"location":"gym-plugin/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent may be embedded into an Autonomous Economic Agent. Demo instructions Follow the Preliminaries and Installation instructions here . Install the gym library. pip install gym Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create the agent In the root directory, create the gym agent. aea create my_gym_agent Add the gym skill cd my_gym_agent aea add skill gym Copy the gym environment to the agent directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Add a gym connection aea add connection gym Update the connection config nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom Run the agent with the gym connection aea run --connection gym You will see the gym training logs. Delete the agent When you're done, you can go up a level and delete the agent. aea delete my_gym_agent","title":"Gym skill"},{"location":"gym-skill/#demo-instructions","text":"Follow the Preliminaries and Installation instructions here . Install the gym library. pip install gym Then, download the examples and packages directory. svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Demo instructions"},{"location":"gym-skill/#create-the-agent","text":"In the root directory, create the gym agent. aea create my_gym_agent","title":"Create the agent"},{"location":"gym-skill/#add-the-gym-skill","text":"cd my_gym_agent aea add skill gym","title":"Add the gym skill"},{"location":"gym-skill/#copy-the-gym-environment-to-the-agent-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the agent directory"},{"location":"gym-skill/#add-a-gym-connection","text":"aea add connection gym","title":"Add a gym connection"},{"location":"gym-skill/#update-the-connection-config","text":"nano connections/gym/connection.yaml env: gyms.env.BanditNArmedRandom","title":"Update the connection config"},{"location":"gym-skill/#run-the-agent-with-the-gym-connection","text":"aea run --connection gym You will see the gym training logs.","title":"Run the agent with the gym connection"},{"location":"gym-skill/#delete-the-agent","text":"When you're done, you can go up a level and delete the agent. aea delete my_gym_agent","title":"Delete the agent"},{"location":"integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.AI and third party ledgers. Fetch.AI Ledger Note Coming soon. Ethereum Ledger Note Coming soon.","title":"Integrate with third parties"},{"location":"integration/#fetchai-ledger","text":"Note Coming soon.","title":"Fetch.AI Ledger"},{"location":"integration/#ethereum-ledger","text":"Note Coming soon.","title":"Ethereum Ledger"},{"location":"protocol/","text":"A Protocol manages message representation, encoding, and serialisation. It also defines the rules to which messages must adhere. An agent can have one or more protocols. The AEA framework supplies three: oef , fipa , and a default protocol. Custom protocol For a custom protocol, the developer must code methods from two classes. Message.check_consistency(self) This method checks the message data for consistency and raises an error if necessary. Todo For example. Serializer.encode(self, msg: Message) This method encodes a message object into bytes for passing around. Todo For example. Serializer.decode(self, obj: bytes) This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way she or he sees fit. rules.py Note Coming soon. oef protocol The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc. fipa protocol The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Peformative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } } default protocol The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"Protocol"},{"location":"protocol/#custom-protocol","text":"For a custom protocol, the developer must code methods from two classes.","title":"Custom protocol"},{"location":"protocol/#messagecheck_consistencyself","text":"This method checks the message data for consistency and raises an error if necessary. Todo For example.","title":"Message.check_consistency(self)"},{"location":"protocol/#serializerencodeself-msg-message","text":"This method encodes a message object into bytes for passing around. Todo For example.","title":"Serializer.encode(self, msg: Message)"},{"location":"protocol/#serializerdecodeself-obj-bytes","text":"This method decodes the byte representation of a message object. Todo For example. Outside of these, the developer is free to implement the agent protocols in any way she or he sees fit.","title":"Serializer.decode(self, obj: bytes)"},{"location":"protocol/#rulespy","text":"Note Coming soon.","title":"rules.py"},{"location":"protocol/#oef-protocol","text":"The oef helps agents to search for and find other agents and (for now) talk to them via different protocols. Note In future, the framework will support peer to peer communications. The oef protocol definition includes an OEFMessage class which gets a protocol_id of oef . It defines OEF agent delegation by way of a MessageType Enum. class Type ( Enum ): \"\"\"OEF Message types.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" SEARCH_AGENTS = \"search_agents\" OEF_ERROR = \"oef_error\" DIALOGUE_ERROR = \"dialogue_error\" SEARCH_RESULT = \"search_result\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value It also provides error codes. class OEFErrorOperation ( Enum ): \"\"\"Operation code for the OEF. It is returned in the OEF Error messages.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEARCH_SERVICES_WIDE = 3 SEARCH_AGENTS = 4 SEND_MESSAGE = 5 OTHER = 10000 A models.py module is provided by the oef protocol which includes classes and methods commonly required by OEF agents. These includes a class for serialising json and classes for implementing the OEF query language such as Attribute , Query , etc.","title":"oef protocol"},{"location":"protocol/#fipa-protocol","text":"The fipa protocol definition includes a FIPAMessage class which gets a protocol_id of fipa . It defines FIPA negotiating terms by way of a Peformative(Enum) . class Performative ( Enum ): \"\"\"FIPA performatives.\"\"\" CFP = \"cfp\" PROPOSE = \"propose\" ACCEPT = \"accept\" MATCH_ACCEPT = \"match_accept\" DECLINE = \"decline\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value FIPAMessages are constructed with a message_id , a dialogue_id , a target and peformative . super () . __init__ ( id = message_id , dialogue_id = dialogue_id , target = target , performative = FIPAMessage . Performative ( performative ), ** kwargs ) The fipa.proto file then further qualifies the performatives for protobuf messaging. syntax = \"proto3\" ; package fetch.aea.fipa ; message FIPAMessage { message CFP { message Nothing { } oneof query { bytes bytes = 2 ; Nothing nothing = 3 ; } } message Propose { repeated bytes proposal = 4 ; } message Accept {} message MatchAccept {} message Decline {} int32 message_id = 1 ; int32 dialogue_id = 2 ; int32 target = 3 ; oneof performative { CFP cfp = 4 ; Propose propose = 5 ; Accept accept = 6 ; MatchAccept match_accept = 7 ; Decline decline = 8 ; } }","title":"fipa protocol"},{"location":"protocol/#default-protocol","text":"The default protocol has a DefaultMessage class which gets a protocol_id of default . It has two message types: BYTES and ERROR , and provides error messages for the error skill which uses it. The serialisation methods encode and decode implement transformations from Message type to bytes and back.","title":"default protocol"},{"location":"quickstart/","text":"Preliminaries Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell Installation Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA inclusive the CLI extension, alone. pip install aea [ cli ] Echo skill demo The echo skill is a simple demo that prints logs from the agent's main loop as it calls registered Task and Behaviour code. Download the scripts and packages directories. svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages Create a new agent aea create my_first_agent Add the echo skill cd my_first_agent aea add skill echo Add a local connection aea add connection local A local connection provides a local stub for an OEF node instance. Run the agent Run the agent with the local connection. aea run --connection local You will see the echo task running in the terminal window. Delete the agent When you're done, you can delete the agent. aea delete my_first_agent","title":"AEA quick start"},{"location":"quickstart/#preliminaries","text":"Create and cd into a new working directory. mkdir my_aea/ cd my_aea/ We highly recommend using a virtual environment to ensure consistency across dependencies. Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it. touch Pipfile && pipenv --python 3 .7 && pipenv shell","title":"Preliminaries"},{"location":"quickstart/#installation","text":"Install the Autonomous Economic Agent framework. The following installs the entire AEA package which includes the cli too. pip install aea [ all ] However, you can run this demo by installing the base AEA inclusive the CLI extension, alone. pip install aea [ cli ]","title":"Installation"},{"location":"quickstart/#echo-skill-demo","text":"The echo skill is a simple demo that prints logs from the agent's main loop as it calls registered Task and Behaviour code.","title":"Echo skill demo"},{"location":"quickstart/#download-the-scripts-and-packages-directories","text":"svn export https://github.com/fetchai/agents-aea.git/trunk/scripts svn export https://github.com/fetchai/agents-aea.git/trunk/packages","title":"Download the scripts and packages directories."},{"location":"quickstart/#create-a-new-agent","text":"aea create my_first_agent","title":"Create a new agent"},{"location":"quickstart/#add-the-echo-skill","text":"cd my_first_agent aea add skill echo","title":"Add the echo skill"},{"location":"quickstart/#add-a-local-connection","text":"aea add connection local A local connection provides a local stub for an OEF node instance.","title":"Add a local connection"},{"location":"quickstart/#run-the-agent","text":"Run the agent with the local connection. aea run --connection local You will see the echo task running in the terminal window.","title":"Run the agent"},{"location":"quickstart/#delete-the-agent","text":"When you're done, you can delete the agent. aea delete my_first_agent","title":"Delete the agent"},{"location":"scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml . Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a connection aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffolding"},{"location":"scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, and connections to the agent. For example, create a new AEA project. aea create my_agent cd my_agent Then, cd into your project directory and scaffold your project skill, protocol, or connection. You will see the directories filled out with the files required and the skill, protocol, or connection registered in the top level aea-config.yaml .","title":"Scaffold generator"},{"location":"scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you will have the fully constructed file system required by the AEA.","title":"Scaffold a connection"},{"location":"skill/","text":"An agent developer writes skill code that the framework can call. When you add a skill with the CLI, a directory is created which includes modules for the Behaviour, Task , and Handler classes as well as a configuration file skill.yaml . Context The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context has a link to the agent context also. The agent context provides read access to agent specific information like the private key of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example. behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer subclasses abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example. tasks.py Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example. Shared classes The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class Skill config Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ] Error skill All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios. Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered). Envelopes with decoding errors. Invalid messages with respect to the registered protocol. The error skill relies on the default protocol which provides error codes for the above.","title":"Skill"},{"location":"skill/#context","text":"The skill has a context object which is shared by all Handler , Behaviour , and Task objects. The skill context has a link to the agent context also. The agent context provides read access to agent specific information like the private key of the agent, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the agent. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( to = recipient , sender = self . context . agent_public_key , protocol_id = DefaultMessage . protocol_id , message = DefaultSerializer () . encode ( reply )) Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Envelope objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle_envelope(self, Envelope) : is where the skill receives a message contained within an Envelope and decides what to do with it. Todo For example.","title":"handlers.py"},{"location":"skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the agent rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer subclasses abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. Todo For example.","title":"behaviours.py"},{"location":"skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the agent requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . Todo For example.","title":"tasks.py"},{"location":"skill/#shared-classes","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end the developer can subclass an abstract SharedClass . These shared classes are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeClass class SomeClass ( SharedClass ): ... Then, an instance of this class is available on the context level like so: some_class = self . context . some_class","title":"Shared classes"},{"location":"skill/#skill-config","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, modules of type SharedClass , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : Fetch.AI Limited version : 0.1.0 license : Apache 2.0 url : \"\" behaviours : - behaviour : class_name : EchoBehaviour args : foo : bar handlers : - handler : class_name : EchoHandler args : foo : bar bar : foo tasks : - task : class_name : EchoTask args : foo : bar bar : foo shared_classes : [] dependencies : - dependency : class_name : EchoDependency args : foo : bar bar : foo protocols : [ \"default\" ]","title":"Skill config"},{"location":"skill/#error-skill","text":"All top level AEA skills directories receive a default error skill that contains error handling code for a number of scenarios. Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered). Envelopes with decoding errors. Invalid messages with respect to the registered protocol. The error skill relies on the default protocol which provides error codes for the above.","title":"Error skill"},{"location":"steps/","text":"There are a number of ways to build an agent. We recommended you build an AEA project with the CLI tool as mentioned in the quick start guide. See information on the CLI tool here . [Coming soon!] Using the cli fetch command, pull in an already built project and run as normal. The last option is to install the AEA without the cli tool with pip install aea and, from there, import classes directly. Set up your skills . Code the protocols . Add the connections . Scaffold any of the above resources with the scaffolding tool . Now, build and run your agent using the quick start guide .","title":"Step by step"},{"location":"tac-skill/","text":"Todo","title":"TAC skill"},{"location":"tac/","text":"TAC has its own repo. Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include submodules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Launcher GUI Todo Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"tac/#quick-start","text":"Clone the repo to include submodules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"tac/#launcher-gui","text":"Todo","title":"Launcher GUI"},{"location":"tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"version/","text":"The current version of the Autonomous Economic Agent framework is 0.1.x . The framework is under rapid development with frequent breaking changes.","title":"Version"},{"location":"weather-skills/","text":"The AEA wheather skills demonstrates a scenario where two AEA agents interact, one as the provider of weather data, the other as the seller of weather data. Demo instructions Follow the Preliminaries and Installation instructions here . Download the packages and scripts directories. svn export https://github.com/fetchai/agents-aea.git/trunk/packages svn export https://github.com/fetchai/agents-aea.git/trunk/scripts Launch the OEF Node: In a separate terminal, launch an OEF node locally: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json Create the weather station agent: In the root directory, create the weather station agent. aea create my_weather_station Add the weather station skill cd my_weather_station aea add skill weather_station Run the weather station agent aea run Create the weather client agent: Return to the root directory, and create the weather client agent. aea create my_weather_client Add the weather client skill cd my_weather_client aea add skill weather_client Run the weather client agent aea run Observe the logs of both agents: Delete the agents When you're done, you can go up a level and delete the agents. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Weather skills"},{"location":"weather-skills/#demo-instructions","text":"Follow the Preliminaries and Installation instructions here . Download the packages and scripts directories. svn export https://github.com/fetchai/agents-aea.git/trunk/packages svn export https://github.com/fetchai/agents-aea.git/trunk/scripts","title":"Demo instructions"},{"location":"weather-skills/#launch-the-oef-node","text":"In a separate terminal, launch an OEF node locally: python scripts/oef/launch.py -c ./scripts/oef/launch_config.json","title":"Launch the OEF Node:"},{"location":"weather-skills/#create-the-weather-station-agent","text":"In the root directory, create the weather station agent. aea create my_weather_station","title":"Create the weather station agent:"},{"location":"weather-skills/#add-the-weather-station-skill","text":"cd my_weather_station aea add skill weather_station","title":"Add the weather station skill"},{"location":"weather-skills/#run-the-weather-station-agent","text":"aea run","title":"Run the weather station agent"},{"location":"weather-skills/#create-the-weather-client-agent","text":"Return to the root directory, and create the weather client agent. aea create my_weather_client","title":"Create the weather client agent:"},{"location":"weather-skills/#add-the-weather-client-skill","text":"cd my_weather_client aea add skill weather_client","title":"Add the weather client skill"},{"location":"weather-skills/#run-the-weather-client-agent","text":"aea run","title":"Run the weather client agent"},{"location":"weather-skills/#observe-the-logs-of-both-agents","text":"","title":"Observe the logs of both agents:"},{"location":"weather-skills/#delete-the-agents","text":"When you're done, you can go up a level and delete the agents. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Delete the agents"}]}