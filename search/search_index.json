{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AEA - Autonomous Economic Agent Framework The AEA framework allows you to quickly assemble autonomous economic agents. Through its modularity AEAs are easily extenable and highly composable. Quickstart pip install -i https://test.pypi.org/simple/ aea create a new AEA project aea create my_first_agent CD into the project folder and add the echo skill to the agent aea add skill echo run the agent on a local network aea run AEA file structure An agent is structured in a directory with a configuration file, a directory with skills, a directory with protocols, a directory with connections and a main logic file that is used when running aea run. agentName/ The root of the agent agent.yml YAML configuration of the agent connections/ Directory containing all the supported connections connection1/ Connection 1 ... ... connectionN/ Connection N protocols/ Directory containing all supported protocols protocol1/ Protocol 1 ... ... protocolK/ Protocol K skills/ Directory containing all the skill components skill1/ Skill 1 ... ... skillN/ Skill L AEA Core Components The Envelope is the core object which agents use to communicate with each other. An Envelope has four attributes: to : defines the destination address sender : defines the sender address protocol_id : defines the protocol_id message : is a bytes field to hold the message in serialized form. AEA Protocols Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol might have a message of type START and FINISH. Then the rules could prescribe that a message of type FINISH must be preceded by a message of type START. AEA Connections A connection allows the AEA to connect to an external service which has a Python SDK or API. A connection wraps an external SDK or API. AEA Skills A skill can encapsulate any code and ideally delivers economic value to the AEA. Each skill has at most a single Handler and potentially multiple Behaviours and Tasks. The Handler is responsible for dealing with messages of the protocol type for which this skill is registered, as such it encapsulates reactions . A Behaviour encapsulates actions , that is sequences of interactions with other agents initiated by the AEA. Finally, a Task encapsulates background work which is internal to the AEA.","title":"Home"},{"location":"#aea-autonomous-economic-agent-framework","text":"The AEA framework allows you to quickly assemble autonomous economic agents. Through its modularity AEAs are easily extenable and highly composable.","title":"AEA - Autonomous Economic Agent Framework"},{"location":"#quickstart","text":"pip install -i https://test.pypi.org/simple/ aea create a new AEA project aea create my_first_agent CD into the project folder and add the echo skill to the agent aea add skill echo run the agent on a local network aea run","title":"Quickstart"},{"location":"#aea-file-structure","text":"An agent is structured in a directory with a configuration file, a directory with skills, a directory with protocols, a directory with connections and a main logic file that is used when running aea run. agentName/ The root of the agent agent.yml YAML configuration of the agent connections/ Directory containing all the supported connections connection1/ Connection 1 ... ... connectionN/ Connection N protocols/ Directory containing all supported protocols protocol1/ Protocol 1 ... ... protocolK/ Protocol K skills/ Directory containing all the skill components skill1/ Skill 1 ... ... skillN/ Skill L","title":"AEA file structure"},{"location":"#aea-core-components","text":"The Envelope is the core object which agents use to communicate with each other. An Envelope has four attributes: to : defines the destination address sender : defines the sender address protocol_id : defines the protocol_id message : is a bytes field to hold the message in serialized form.","title":"AEA Core Components"},{"location":"#aea-protocols","text":"Protocols define how messages are represented and encoded for transport. They also define the rules to which messages have to adhere in a message sequence. For instance, a protocol might have a message of type START and FINISH. Then the rules could prescribe that a message of type FINISH must be preceded by a message of type START.","title":"AEA Protocols"},{"location":"#aea-connections","text":"A connection allows the AEA to connect to an external service which has a Python SDK or API. A connection wraps an external SDK or API.","title":"AEA Connections"},{"location":"#aea-skills","text":"A skill can encapsulate any code and ideally delivers economic value to the AEA. Each skill has at most a single Handler and potentially multiple Behaviours and Tasks. The Handler is responsible for dealing with messages of the protocol type for which this skill is registered, as such it encapsulates reactions . A Behaviour encapsulates actions , that is sequences of interactions with other agents initiated by the AEA. Finally, a Task encapsulates background work which is internal to the AEA.","title":"AEA Skills"},{"location":"cli_overview/","text":"Command Line Interface The command line interface of the AEA helps you quickly assemble autonomous economic agents. Command Description create [name] Creates a new aea project fetch [name] Fetches an aea project scaffold connection/protocol/skill [name] Scaffolds a new connection, protocol or skill project publish agent/connection/protocol/skill [name] Publishes agent, connection, protocol or skill project add connection/protocol/skill [name] Adds connection, protocol or skill to agent remove connection/protocol/skill [name] Removes connection, protocol or skill from agent run {using [connection, ...]} Runs the agent on the Fetch.AI network with the default or specified connections. deploy {using [connection, ...]} Deploys the agent to a server and runs it on the Fetch.AI network with the default or specified connections. delete [name] Delete an aea project","title":"Overview"},{"location":"cli_overview/#command-line-interface","text":"The command line interface of the AEA helps you quickly assemble autonomous economic agents. Command Description create [name] Creates a new aea project fetch [name] Fetches an aea project scaffold connection/protocol/skill [name] Scaffolds a new connection, protocol or skill project publish agent/connection/protocol/skill [name] Publishes agent, connection, protocol or skill project add connection/protocol/skill [name] Adds connection, protocol or skill to agent remove connection/protocol/skill [name] Removes connection, protocol or skill from agent run {using [connection, ...]} Runs the agent on the Fetch.AI network with the default or specified connections. deploy {using [connection, ...]} Deploys the agent to a server and runs it on the Fetch.AI network with the default or specified connections. delete [name] Delete an aea project","title":"Command Line Interface"},{"location":"ex_rl/","text":"Reinforcement Learning and the AEA Framework We provide two examples to demonstrate the utility of our framework to RL developers. Gym Example The train.py file here shows that all the RL developer needs to do is add one line of code (proxy_env = ...) to introduce our agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. The gym_ex just serves as a demonstration and helps on-boarding, there is no immediate use case for it as you can train your RL agent without our proxy layer just fine (and faster). However, it decouples the RL agent from the gym.Env allowing the two do run in separate environments, potentially owned by different entities. Gym Skill The gym_skill here lets an RL developer embed their RL agent inside an AEA as a skill.","title":"Reinforcement Learning"},{"location":"ex_rl/#reinforcement-learning-and-the-aea-framework","text":"We provide two examples to demonstrate the utility of our framework to RL developers.","title":"Reinforcement Learning and the AEA Framework"},{"location":"ex_rl/#gym-example","text":"The train.py file here shows that all the RL developer needs to do is add one line of code (proxy_env = ...) to introduce our agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. The gym_ex just serves as a demonstration and helps on-boarding, there is no immediate use case for it as you can train your RL agent without our proxy layer just fine (and faster). However, it decouples the RL agent from the gym.Env allowing the two do run in separate environments, potentially owned by different entities.","title":"Gym Example"},{"location":"ex_rl/#gym-skill","text":"The gym_skill here lets an RL developer embed their RL agent inside an AEA as a skill.","title":"Gym Skill"}]}